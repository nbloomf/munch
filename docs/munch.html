<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Munch</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="style.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Munch</h1>
</header>
<p>Let’s build a parser combinator library!</p>
<p>I’ve been using the Parsec library and its descendants to write parsers for years without really knowing how parser combinators work. Today we’re going to try to fix that. In this module we’ll be writing a barebones reimplementation of Parsec (with a few tweaks) from scratch while following along with some relevant papers.</p>
<ul>
<li><em>Parsec: Direct Style Monadic Parser Combinators For The Real World</em> by Daan Leijen and Erik Meijer</li>
<li><em>Indentation-Sensitive Parsing for Parsec</em> by Michael Adams and Ömer Ağacan</li>
<li><em>Parsing Permutation Phrases</em> by Arthur Baars, Andres Löh, and Doaitse Swierstra</li>
</ul>
<p>I’m not super interested in optimization, but in the end we should have a usable parsing library. The goal is to (1) have a small set of parser combinators for building PEG-style parsers with (2) additional primitives for indentation-sensitivity (think <em>relevant whitespace</em>) and for parsing permutation phrases (think <em>command line flags</em>) and to (3) understand how it all works. Along the way I’ll assume that you’re an intermediate FPer – comfortable with type inference and the basic monads – but not necessarily familiar with the guts of parsec.</p>
<p>This document is a literate Haskell module with code and library documentation interspersed among the prose. Code blocks appear with syntax highlighting. Some code isn’t part of the library, but just provides a concrete example. These blocks have a blueish background like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="co">-- This is just an example.</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">testing ::</span> <span class="dt">IO</span> ()</a></code></pre></div>
<p>Code that is part of the library appears on a gray background, like this block of compiler noises.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="ot">{-#</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="ot">  LANGUAGE</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="ot">    ExplicitForAll,</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="ot">    FlexibleContexts,</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="ot">    FlexibleInstances,</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="ot">    ScopedTypeVariables,</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="ot">    UndecidableInstances,</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="ot">    ExistentialQuantification</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="ot">#-}</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="co">{-|</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12"><span class="co">Module      : Text.ParserCombinators.Munch</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13"><span class="co">Description : Simple parser combinator library</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="co">Copyright   : (c) Automattic, Inc. 2018</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="co">License     : GPL-3</span></a>
<a class="sourceLine" id="cb2-16" data-line-number="16"><span class="co">Maintainer  : Nathan Bloomfield, nathan.bloomfield@a8c.com</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17"><span class="co">Stability   : experimental</span></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="co">Portability : POSIX</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"></a>
<a class="sourceLine" id="cb2-20" data-line-number="20"><span class="co">Parser combinator library with support for indentation sensitivity.</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21"><span class="co">-}</span></a>
<a class="sourceLine" id="cb2-22" data-line-number="22"></a>
<a class="sourceLine" id="cb2-23" data-line-number="23"><span class="kw">module</span> <span class="dt">Text.ParserCombinators.Munch</span> (</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">    <span class="co">-- * Usage</span></a>
<a class="sourceLine" id="cb2-25" data-line-number="25">    <span class="co">-- $overview</span></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">    <span class="dt">Parser</span>(), runParser, debugParser, parseIO</a>
<a class="sourceLine" id="cb2-27" data-line-number="27">  , <span class="dt">Stream</span>(), toStream, <span class="dt">Token</span>(<span class="fu">..</span>), <span class="dt">Pos</span>(<span class="fu">..</span>), <span class="dt">DidConsume</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">    <span class="co">-- * Basic Parsers</span></a>
<a class="sourceLine" id="cb2-29" data-line-number="29">  , token, bof, eof, satisfies, anyToken, wouldFail, wouldSucceed</a>
<a class="sourceLine" id="cb2-30" data-line-number="30">  , choice, manySepBy, someSepBy, string</a>
<a class="sourceLine" id="cb2-31" data-line-number="31">    <span class="co">-- ** @Char@</span></a>
<a class="sourceLine" id="cb2-32" data-line-number="32">  , char, newline, spaces, decimalDigit, hexDigit</a>
<a class="sourceLine" id="cb2-33" data-line-number="33">  , lowerLatin, upperLatin</a>
<a class="sourceLine" id="cb2-34" data-line-number="34">    <span class="co">-- * Errors</span></a>
<a class="sourceLine" id="cb2-35" data-line-number="35">  , (<span class="fu">&lt;?&gt;</span>), <span class="dt">Error</span>(<span class="fu">..</span>), <span class="dt">BasicError</span>(<span class="fu">..</span>), <span class="dt">Annotation</span>(<span class="fu">..</span>), <span class="dt">ParseError</span>()</a>
<a class="sourceLine" id="cb2-36" data-line-number="36">  , displayParseError</a>
<a class="sourceLine" id="cb2-37" data-line-number="37">    <span class="co">-- * Indentation</span></a>
<a class="sourceLine" id="cb2-38" data-line-number="38">  , readRef, adjustRef, localRef, consume, ignore</a>
<a class="sourceLine" id="cb2-39" data-line-number="39">  , <span class="dt">Indentation</span>(<span class="fu">..</span>), indent</a>
<a class="sourceLine" id="cb2-40" data-line-number="40">    <span class="co">-- ** Simple Indentation</span></a>
<a class="sourceLine" id="cb2-41" data-line-number="41">  , wrtRef, wrtPos, <span class="dt">Endpoint</span>(<span class="fu">..</span>), <span class="dt">Relation</span>(<span class="fu">..</span>), <span class="dt">Dimension</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-42" data-line-number="42">    <span class="co">-- * Permutations</span></a>
<a class="sourceLine" id="cb2-43" data-line-number="43">  , permute, permuteSepBy, permuteIndent, permuteIndentSepBy</a>
<a class="sourceLine" id="cb2-44" data-line-number="44">  , (<span class="fu">&lt;$$&gt;</span>), (<span class="fu">&lt;&amp;&amp;&gt;</span>), (<span class="fu">&lt;$?&gt;</span>), (<span class="fu">&lt;&amp;?&gt;</span>), <span class="dt">Perms</span>()</a>
<a class="sourceLine" id="cb2-45" data-line-number="45">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-46" data-line-number="46"></a>
<a class="sourceLine" id="cb2-47" data-line-number="47"><span class="kw">import</span> <span class="dt">Data.List</span> (intersperse, unwords)</a>
<a class="sourceLine" id="cb2-48" data-line-number="48"><span class="kw">import</span> <span class="dt">Data.Semigroup</span></a>
<a class="sourceLine" id="cb2-49" data-line-number="49"><span class="kw">import</span> <span class="dt">Data.String</span></a>
<a class="sourceLine" id="cb2-50" data-line-number="50"><span class="kw">import</span> <span class="dt">Data.Word</span> (<span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb2-51" data-line-number="51"><span class="kw">import</span> <span class="dt">Control.Applicative</span></a>
<a class="sourceLine" id="cb2-52" data-line-number="52"><span class="kw">import</span> <span class="dt">Control.Monad</span></a>
<a class="sourceLine" id="cb2-53" data-line-number="53"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.Fail</span> <span class="kw">as</span> <span class="dt">F</span></a>
<a class="sourceLine" id="cb2-54" data-line-number="54"><span class="kw">import</span> <span class="dt">Numeric</span> (showHex)</a></code></pre></div>
<h2 id="contents">Contents</h2>
<ul>
<li>The Library
<ul>
<li><a href="#getting-started">Getting Started</a></li>
<li><a href="#basic-combinators">Basic Combinators</a></li>
<li><a href="#simple-tokens">Simple Tokens</a></li>
<li><a href="#derived-combinators">Derived Combinators</a></li>
<li><a href="#indentation">Indentation</a></li>
<li><a href="#errors">Errors</a></li>
<li><a href="#permutation-phrases">Permutation Phrases</a></li>
</ul></li>
<li>Appendices
<ul>
<li><a href="#pretty-printing">Pretty Printing</a></li>
<li><a href="#an-indentation-dsl">An Indentation DSL</a></li>
<li><a href="#usage-overview">Usage Overview</a></li>
<li><a href="/munch/munch-test.html">Examples</a></li>
</ul></li>
</ul>
<h2 id="getting-started">Getting Started</h2>
<p>A good way to begin thinking about the design of a library, especially in a language with strong types, is to start with the type signatures of the basic concepts. We don’t have to write a fully formed type signature in one go – we can start simple and add complexity one step at a time.</p>
<p>To a first approximation a <em>parser</em> is a function taking a string of characters to a value of some other type <code>a</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> a</a></code></pre></div>
<p>For the simplest possible parsers, and considering only the happy path where the input is always well-formed, this is good enough. But of course real parsers are complicated and real input is malformed, and the mark of a good parser is the error messages it reports when we go off of the happy path. If something goes wrong, parsing should report some diagnostic error. We can do this with <code>Either</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> a</a></code></pre></div>
<p>Don’t worry about what <code>ParseError</code> looks like for now – just assume it carries some information about what broke.</p>
<p>This signature makes an implicit assumption: that our parser will consume the entire input string. This should be true for top-level parsers (if there are no errors) but the point of using combinators is to build big parsers out of small ones, and small parsers definitely should <em>not</em> consume the entire input string. So the output should include the “unconsumed” portion of the input. We have to decide whether to return this inside or outside the <code>Either</code>; in other words, whether to return the unconsumed string with the error value. I’ll put it inside, though I can’t think of a reason why this is the only correct choice.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">ParseError</span> (a, <span class="dt">String</span>)</a></code></pre></div>
<p>This is a decent parser type signature. However, as Leijen and Meijer discuss in their paper, there is a significant efficiency boost to be had if the parse function also returns whether or not it actually consumed any input. The Parsec paper does this with an intermediate type constructor, but I’m pretty sure we can get the same benefits from a tuple. We will make one tweak – rather than just reporting whether or not any characters are consumed, we’ll also report the inclusive range of character positions that were consumed.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="ot">parse ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">DidConsume</span>, <span class="dt">Either</span> <span class="dt">ParseError</span> (a, <span class="dt">String</span>))</a></code></pre></div>
<p>The <code>DidConsume</code> type is defined like so.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- | Represents whether a parser consumed part of the input stream.</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="kw">data</span> <span class="dt">DidConsume</span> t</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="fu">=</span> <span class="dt">Declined</span>                 <span class="co">-- ^ The parse did not consume any</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">                             <span class="co">--   characters.</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Consumed</span> (<span class="dt">Pos</span> t) (<span class="dt">Pos</span> t) <span class="co">-- ^ The parse consumed input characters</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">                             <span class="co">--   between two positions (inclusive).</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="co">-- | @Pos@ represents a position in the input stream consisting of</span></a>
<a class="sourceLine" id="cb7-10" data-line-number="10"><span class="co">--   a /line number/ and a /column number/, both of which are</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="co">--   nonnegative integers. The @Ord@ instance is lexicographic by</span></a>
<a class="sourceLine" id="cb7-12" data-line-number="12"><span class="co">--   line, then column. </span></a>
<a class="sourceLine" id="cb7-13" data-line-number="13"><span class="kw">data</span> <span class="dt">Pos</span> t <span class="fu">=</span> <span class="dt">Pos</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  {<span class="ot"> line ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  ,<span class="ot"> column ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Note that “parse consumed characters” and “parse succeeded” are orthogonal. This is important. Note also that the location of <code>DidConsume</code> in the signature of <code>parse</code> fits the classic writer monad pattern. To make this legit, <code>DidConsume</code> will need a <code>Monoid</code> instance – that is, we need a natural way to combine two pieces of information about consumption into a single one. The Parsec paper talks about this (albeit in the language of type constructors, rather than data): if <code>a</code> and <code>b</code> are <code>DidConsume</code>s, then <code>a &lt;&gt; b</code> should be <code>Consumed</code> if either <code>a</code> or <code>b</code> is, and should be <code>Declined</code> otherwise. The simplest way I can think of to combine two ranges is to construct their “convex hull”; the smallest range containing both. Concretely:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="co">-- | The product of two @Consumed@ ranges is their convex hull. This is</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="co">--   the direct product of the @min@ and @max@ semigroups over @Integer@</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3"><span class="co">--   with a unit attached.</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">DidConsume</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Declined</span>       <span class="fu">&lt;&gt;</span> <span class="dt">Declined</span>       <span class="fu">=</span> <span class="dt">Declined</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="dt">Consumed</span> a1 b1 <span class="fu">&lt;&gt;</span> <span class="dt">Declined</span>       <span class="fu">=</span> <span class="dt">Consumed</span> a1 b1</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="dt">Declined</span>       <span class="fu">&lt;&gt;</span> <span class="dt">Consumed</span> a2 b2 <span class="fu">=</span> <span class="dt">Consumed</span> a2 b2</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  <span class="dt">Consumed</span> a1 b1 <span class="fu">&lt;&gt;</span> <span class="dt">Consumed</span> a2 b2 <span class="fu">=</span> <span class="dt">Consumed</span> (min a1 a2) (max b1 b2)</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">DidConsume</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  mempty  <span class="fu">=</span> <span class="dt">Declined</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  mappend <span class="fu">=</span> (<span class="fu">&lt;&gt;</span>)</a></code></pre></div>
<p>This sort of makes sense; in the typical case where two ranges are directly adjacent, the convex hull is the same as concatenation. Note that this is a bona fide <code>Monoid</code> since it is (isomorphic to) the direct product of the min and max semigroups over <code>Integer</code> with a unit attached. Note, however, that we’re not making any assumptions about whether the “left” endpoint in a consumed range comes before the “right” endpoint – and if that’s the case this isn’t really computing the convex hull, although this shouldn’t happen in practice.</p>
<p>Parsec makes one more basic adjustment to this type: rather than parsing <code>String</code>s, it parses values of any type satisfying a <code>Stream</code> class. We will do something similar, but to simplify matters rather than abstracting over the <em>stream</em> we’ll just abstract over the <em>token</em> type. Streams will all be modeled as lists of tokens together with the <code>Pos</code> of the first token.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Stream</span> t <span class="fu">=</span> <span class="dt">Stream</span> (<span class="dt">Pos</span> t) [t]</a>
<a class="sourceLine" id="cb9-2" data-line-number="2"></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="co">-- | @True@ if there are no characters left in the stream.</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">isEmpty ::</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">isEmpty (<span class="dt">Stream</span> _ xs) <span class="fu">=</span> null xs</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"></a>
<a class="sourceLine" id="cb9-7" data-line-number="7"><span class="co">-- | @Just@ the @Pos@ at the head of the stream, or @Nothing@</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8"><span class="co">--   if the stream is empty.</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9"><span class="ot">pointer ::</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">pointer (<span class="dt">Stream</span> pos xs) <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  [] <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  _  <span class="ot">-&gt;</span> <span class="dt">Just</span> pos</a></code></pre></div>
<p>The <code>t</code> type represents our tokens. So our parsers will have a type like this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">parser</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">  ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> (<span class="dt">DidConsume</span>, <span class="dt">Either</span> <span class="dt">ParseError</span> (a, <span class="dt">Stream</span> t))</a></code></pre></div>
<p>But what exactly should be special about tokens? The most important thing we will do with streams is read the head token (if it exists) and return the remaining stream. This will require <em>updating</em> the head position, typically taking into account which token was taken. We also need a canonical choice for the <em>initial</em> position for a given token type.</p>
<p>With this in mind, we define the <code>Token</code> class like so.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="co">-- | Class representing types of &quot;parseable&quot; tokens.</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Token</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="co">-- | Initial token position</span></a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="ot">  initPos ::</span> <span class="dt">Pos</span> t</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6">  <span class="co">-- | Given a token and a position, update to a new position.</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="ot">  updatePos ::</span> t <span class="ot">-&gt;</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">Pos</span> t</a>
<a class="sourceLine" id="cb11-8" data-line-number="8"></a>
<a class="sourceLine" id="cb11-9" data-line-number="9">  <span class="co">-- | Token specific pretty printer for @Pos@s</span></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"><span class="ot">  formatPos ::</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">String</span></a></code></pre></div>
<p>With these functions in hand, we can define <code>toStream</code> and <code>popToken</code> for arbitrary token types.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="co">-- | Construct a stream from a list, using `initPos`.</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">toStream ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> [t] <span class="ot">-&gt;</span> <span class="dt">Stream</span> t</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">toStream <span class="fu">=</span> <span class="dt">Stream</span> initPos</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"></a>
<a class="sourceLine" id="cb12-5" data-line-number="5"><span class="co">-- | If any characters remain in the stream, returns the</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6"><span class="co">--   first one with its position and the rest of the stream.</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7"><span class="ot">popToken ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (t, <span class="dt">Pos</span> t, <span class="dt">Stream</span> t)</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">popToken (<span class="dt">Stream</span> pos xs) <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">  []   <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">  z<span class="fu">:</span>zs <span class="ot">-&gt;</span> <span class="dt">Just</span> (z, pos, <span class="dt">Stream</span> (updatePos z pos) zs)</a></code></pre></div>
<p>From this point of view, <code>Pos</code> is what makes token streams interesting – they have a natural “first” position, used by <code>toStream</code>, and given a token, we can update to a natural “next” token. For instance, when parsing text positions are line and column numbers, but when parsing binary data positions are byte offsets.</p>
<p>I’m going to make one final adjustment to the parser type to accommodate <em>indentation sensitive parsing</em>. While writing this up, I read the Adams and Ağacan paper on parsing indentation, and have to admit I wasn’t able to get it to work – which, to be clear, is entirely my failing. That paper is a nice read and has some really good ideas. Although I couldn’t get the exact implementation working, I will take inspiration and try to add indentation-sensitivity to this library. And since we’re basically reimplementing parsec from scratch we can afford to sidestep some of the compromises that paper has to make as a result of trying to integrate with existing code.</p>
<p>We’ve already attached a <code>Pos</code> to each lexeme in the input stream. In the most general terms, a parser is <em>indentation sensitive</em> if it only succeeds when it successfully consumes some characters <em>and</em> the positions at which it succeeds satisfy an extra constraint. This definition is a little too general, so to narrow our space of design decisions lets be more specific.</p>
<p>Our parsers will carry one more piece of state, a <code>Pos</code> called the <em>reference position</em>. All intentation sensitive primitives will be defined in terms of this reference. But we have a choice to make. What kind of state is this? It certainly needs to be readable so we can detect invalid indentations. But does it need to be writeable? Should we model the indentation stack using <code>State</code> or <code>Reader</code>? By representing indentation with <code>State</code>, we allow any parser to implicitly fiddle with the reference position of any other. On the other hand, with <code>Reader</code>, any changes to the reference position are explicit at the call site. The tradeoff with <code>Reader</code> is that state changes <em>must</em> be explicit. Since debugging parsers is hard enough without mutable state; I’ll go with <code>Reader</code>.</p>
<p>So our final parser type looks like this. Note how <code>Pos</code> only appears on the left of an arrow.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="co">-- | The opaque type of a parser over `Char` streams of type `s`</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="co">--   producing a value of type `a`. Parsers are built up using</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3"><span class="co">--   the @Applicative@, @Alternative@, and @Monad@ interfaces</span></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="co">--   and the atomic parsers defined in this module.</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5"><span class="kw">data</span> <span class="dt">Parser</span> t a <span class="fu">=</span> <span class="dt">Parser</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  { theParser</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="ot">      ::</span> <span class="dt">Pos</span> t</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">      <span class="ot">-&gt;</span> <span class="dt">Stream</span> t</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">      <span class="ot">-&gt;</span> ( <span class="dt">DidConsume</span> t</a>
<a class="sourceLine" id="cb13-10" data-line-number="10">         , <span class="dt">Either</span> (<span class="dt">ParseError</span> t) (a, <span class="dt">Stream</span> t)</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">         )</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">  }</a></code></pre></div>
<p>Last but not least we sometimes need to actually <em>run</em> a parser, and since parsers are just functions that that means evaluate. We’ll do this in three ways: one that returns all the gory details, one that just returns a result, and one that just pretty prints the result.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="co">-- | Run a parser against a stream, returning the result as well</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="co">--   as the consumed range and the remaining stream.</span></a>
<a class="sourceLine" id="cb14-3" data-line-number="3">debugParser</a>
<a class="sourceLine" id="cb14-4" data-line-number="4"><span class="ot">  ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">  <span class="ot">-&gt;</span> <span class="dt">Stream</span> t</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  <span class="ot">-&gt;</span> (<span class="dt">DidConsume</span> t, <span class="dt">Either</span> (<span class="dt">ParseError</span> t) (a, <span class="dt">Stream</span> t))</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">debugParser (<span class="dt">Parser</span> q) stream <span class="fu">=</span> q initPos stream</a>
<a class="sourceLine" id="cb14-9" data-line-number="9"></a>
<a class="sourceLine" id="cb14-10" data-line-number="10"><span class="co">-- | Run a parser against a stream, returning only the result.</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">runParser</a>
<a class="sourceLine" id="cb14-12" data-line-number="12"><span class="ot">  ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb14-13" data-line-number="13">  <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> <span class="dt">Either</span> (<span class="dt">ParseError</span> t) a</a>
<a class="sourceLine" id="cb14-14" data-line-number="14">runParser (<span class="dt">Parser</span> q) stream <span class="fu">=</span> <span class="kw">case</span> q initPos stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">  (_, <span class="dt">Left</span> err) <span class="ot">-&gt;</span> <span class="dt">Left</span> err</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">  (_, <span class="dt">Right</span> (a, rest)) <span class="ot">-&gt;</span> <span class="kw">if</span> isEmpty rest</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">    <span class="kw">then</span> <span class="dt">Right</span> a</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">    <span class="kw">else</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">IncompleteParse</span> (pointer rest)</a>
<a class="sourceLine" id="cb14-19" data-line-number="19"></a>
<a class="sourceLine" id="cb14-20" data-line-number="20"><span class="co">-- | Pretty print the result of a parse.</span></a>
<a class="sourceLine" id="cb14-21" data-line-number="21">parseIO</a>
<a class="sourceLine" id="cb14-22" data-line-number="22"><span class="ot">  ::</span> (<span class="dt">Token</span> t, <span class="dt">Pretty</span> t, <span class="dt">Show</span> a)</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">  <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Stream</span> t <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">parseIO (<span class="dt">Parser</span> q) stream <span class="fu">=</span> <span class="kw">case</span> q initPos stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-25" data-line-number="25">  (_, <span class="dt">Left</span> err) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-26" data-line-number="26">    putStrLn <span class="st">&quot;Parse Error&quot;</span></a>
<a class="sourceLine" id="cb14-27" data-line-number="27">    putStrLn <span class="fu">$</span> pretty err</a>
<a class="sourceLine" id="cb14-28" data-line-number="28">  (_, <span class="dt">Right</span> (a, rest)) <span class="ot">-&gt;</span> <span class="kw">if</span> isEmpty rest</a>
<a class="sourceLine" id="cb14-29" data-line-number="29">    <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-30" data-line-number="30">      putStrLn <span class="st">&quot;Parse OK&quot;</span></a>
<a class="sourceLine" id="cb14-31" data-line-number="31">      putStrLn <span class="fu">$</span> show a</a>
<a class="sourceLine" id="cb14-32" data-line-number="32">    <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-33" data-line-number="33">      putStrLn <span class="st">&quot;Parse Incomplete&quot;</span></a>
<a class="sourceLine" id="cb14-34" data-line-number="34">      putStrLn <span class="fu">$</span> show <span class="fu">$</span> pointer rest</a></code></pre></div>
<h2 id="basic-combinators">Basic Combinators</h2>
<p>The <code>Parser s</code> type constructor is defined as a stack of monads – state, error, writer, and reader. When this happens our first instinct should be to write the monad implementation, because this gives us a huge amount of code for free. This part is mostly standard stuff.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Parser</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  fmap f (<span class="dt">Parser</span> q) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="kw">let</span> (c, result) <span class="fu">=</span> q ref stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      <span class="dt">Left</span> err <span class="ot">-&gt;</span> (c, <span class="dt">Left</span> err)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">      <span class="dt">Right</span> (a, rest) <span class="ot">-&gt;</span> (c, <span class="dt">Right</span> (f a, rest))</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Parser</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9">  pure x <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-10" data-line-number="10">    (<span class="dt">Declined</span>, <span class="dt">Right</span> (x, stream))</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">  af <span class="fu">&lt;*&gt;</span> ax <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    f <span class="ot">&lt;-</span> af</a>
<a class="sourceLine" id="cb15-14" data-line-number="14">    x <span class="ot">&lt;-</span> ax</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">    return (f x)</a></code></pre></div>
<p>The implementation of the <code>&lt;|&gt;</code> operator in the <code>Alternative</code> instance represents PEG style ordered choice; if the left parser fails, we pretend no input was consumed and try the right parser. Ignore what’s happening with the errors here – we’ll get to that. Just note that <code>empty</code> is supposed to be neutral for <code>&lt;|&gt;</code>, which requires errors to form a monoid.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="co">-- | The @\&lt;|&gt;@ operator implements /ordered choice/; we try the left</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="co">--   parser, and if it fails, pretend it did not consume any input and</span></a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="co">--   try the right parser. If both fail we report a combination of</span></a>
<a class="sourceLine" id="cb16-4" data-line-number="4"><span class="co">--   their error messages. @empty@ represents a generic failure. It&#39;s</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5"><span class="co">--   included for completeness but should usually be avoided.</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6"><span class="kw">instance</span> <span class="dt">Alternative</span> (<span class="dt">Parser</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">  <span class="co">-- generic failure</span></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">  empty <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    (<span class="dt">Declined</span>, <span class="dt">Left</span> mempty)</a>
<a class="sourceLine" id="cb16-10" data-line-number="10"></a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="co">-- ordered choice</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  (<span class="dt">Parser</span> a) <span class="fu">&lt;|&gt;</span> (<span class="dt">Parser</span> b) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-13" data-line-number="13">    <span class="kw">case</span> a ref stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-14" data-line-number="14">      (c, <span class="dt">Right</span> value) <span class="ot">-&gt;</span> (c, <span class="dt">Right</span> value)</a>
<a class="sourceLine" id="cb16-15" data-line-number="15">      (_, <span class="dt">Left</span> err1) <span class="ot">-&gt;</span> <span class="kw">case</span> b ref stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-16" data-line-number="16">        (c, <span class="dt">Right</span> value) <span class="ot">-&gt;</span> (c, <span class="dt">Right</span> value)</a>
<a class="sourceLine" id="cb16-17" data-line-number="17">        (c, <span class="dt">Left</span> err2) <span class="ot">-&gt;</span> (c, <span class="dt">Left</span> <span class="fu">$</span> err1 <span class="fu">&lt;&gt;</span> err2)</a></code></pre></div>
<p>The <code>&gt;&gt;</code> operator in the <code>Monad</code> instance represents PEG style sequencing.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Parser</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb17-3" data-line-number="3"></a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  (<span class="dt">Parser</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    <span class="kw">let</span> (c, result) <span class="fu">=</span> x ref stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">    <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">      <span class="dt">Declined</span> <span class="ot">-&gt;</span> <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">        <span class="dt">Left</span> err <span class="ot">-&gt;</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> err)</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">        <span class="dt">Right</span> (a, rest) <span class="ot">-&gt;</span> theParser (f a) ref rest</a>
<a class="sourceLine" id="cb17-10" data-line-number="10"></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">      c1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">          (c2, h) <span class="fu">=</span> <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">            <span class="dt">Left</span> err <span class="ot">-&gt;</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> err)</a>
<a class="sourceLine" id="cb17-15" data-line-number="15">            <span class="dt">Right</span> (a, rest) <span class="ot">-&gt;</span> theParser (f a) ref rest</a>
<a class="sourceLine" id="cb17-16" data-line-number="16">        <span class="kw">in</span> (c1 <span class="fu">&lt;&gt;</span> c2, h)</a>
<a class="sourceLine" id="cb17-17" data-line-number="17"></a>
<a class="sourceLine" id="cb17-18" data-line-number="18"><span class="co">-- | Default instance in terms of @Alternative@.</span></a>
<a class="sourceLine" id="cb17-19" data-line-number="19"><span class="kw">instance</span> <span class="dt">MonadPlus</span> (<span class="dt">Parser</span> t)</a></code></pre></div>
<p>We can also give a <code>MonadFail</code> instance. This typeclass isn’t as “natural” as <code>Functor</code> and <code>Monad</code>, but <code>fail</code> is a really useful utility – it lets us stop the world and fail the parse for any reason.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">F.MonadFail</span> (<span class="dt">Parser</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  fail msg <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">    (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">Failure</span> msg (pointer stream))</a></code></pre></div>
<p>We can also give <code>Parser t a</code> a <code>Semigroup</code> and <code>Monoid</code> instance.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1"><span class="co">-- | The @\&lt;&gt;@ implementation allows us to combine the results of</span></a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="co">--   two parsers. Compare to @&gt;&gt;@, @*&gt;@, and @&lt;*@, which combine two</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3"><span class="co">--   parsers but only return the result of one.</span></a>
<a class="sourceLine" id="cb19-4" data-line-number="4"><span class="kw">instance</span> (<span class="dt">Semigroup</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">Parser</span> t a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  (<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> liftA2 (<span class="fu">&lt;&gt;</span>)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"></a>
<a class="sourceLine" id="cb19-7" data-line-number="7"><span class="kw">instance</span> (<span class="dt">Monoid</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">Parser</span> t a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  mempty  <span class="fu">=</span> return mempty</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">  mappend <span class="fu">=</span> liftA2 mappend</a></code></pre></div>
<p>At this point we’ve already got a huge built-in library of utility functions based on <code>Functor</code>, <code>Applicative</code>, <code>Alternative</code>, and <code>Monad</code>, but not any concrete parsers (other than <code>return</code>). To address this we’ll also define some atomic parsers for recognizing tokens and the beginning and end of the stream.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="co">-- | Expects the specified token.</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">token ::</span> (<span class="dt">Token</span> t, <span class="dt">Eq</span> t) <span class="ot">=&gt;</span> t <span class="ot">-&gt;</span> <span class="dt">Parser</span> t t</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">token c <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">  <span class="kw">case</span> popToken stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">      (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedEOF</span> (<span class="dt">Right</span> <span class="fu">$</span> <span class="dt">Just</span> c))</a>
<a class="sourceLine" id="cb20-7" data-line-number="7"></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    <span class="dt">Just</span> (a,pos,rest) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">      <span class="kw">if</span> a <span class="fu">==</span> c</a>
<a class="sourceLine" id="cb20-10" data-line-number="10">        <span class="kw">then</span> (<span class="dt">Consumed</span> pos pos, <span class="dt">Right</span> (a, rest))</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">        <span class="kw">else</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedToken</span> a (<span class="dt">Just</span> c) pos)</a>
<a class="sourceLine" id="cb20-12" data-line-number="12"></a>
<a class="sourceLine" id="cb20-13" data-line-number="13"><span class="co">-- | Expects the end of the stream.</span></a>
<a class="sourceLine" id="cb20-14" data-line-number="14"><span class="ot">eof ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t ()</a>
<a class="sourceLine" id="cb20-15" data-line-number="15">eof <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-16" data-line-number="16">  <span class="kw">case</span> popToken stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-17" data-line-number="17">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">      (<span class="dt">Declined</span>, <span class="dt">Right</span> ((), stream))</a>
<a class="sourceLine" id="cb20-19" data-line-number="19"></a>
<a class="sourceLine" id="cb20-20" data-line-number="20">    <span class="dt">Just</span> (a,pos,_) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-21" data-line-number="21">      (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedToken</span> a <span class="dt">Nothing</span> pos)</a>
<a class="sourceLine" id="cb20-22" data-line-number="22"></a>
<a class="sourceLine" id="cb20-23" data-line-number="23"><span class="co">-- | Expects the beginning of the stream.</span></a>
<a class="sourceLine" id="cb20-24" data-line-number="24"><span class="ot">bof ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t ()</a>
<a class="sourceLine" id="cb20-25" data-line-number="25">bof <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-26" data-line-number="26">  <span class="kw">case</span> popToken stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-27" data-line-number="27">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-28" data-line-number="28">      (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedEOF</span> (<span class="dt">Right</span> <span class="dt">Nothing</span>))</a>
<a class="sourceLine" id="cb20-29" data-line-number="29"></a>
<a class="sourceLine" id="cb20-30" data-line-number="30">    <span class="dt">Just</span> (_,pos,_) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-31" data-line-number="31">      <span class="kw">if</span> pos <span class="fu">==</span> <span class="dt">Pos</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb20-32" data-line-number="32">        <span class="kw">then</span> (<span class="dt">Declined</span>, <span class="dt">Right</span> ((), stream))</a>
<a class="sourceLine" id="cb20-33" data-line-number="33">        <span class="kw">else</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">ExpectedBOF</span> pos)</a></code></pre></div>
<p>Slightly more general than <code>token</code> is <code>satisfies</code>, which accepts characters that satisfy some given predicate. In principle <code>satisfies</code> is redundant, since it can be implemented in terms of <code>token</code> and <code>&lt;|&gt;</code>. But in practice it makes error messages much nicer.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1"><span class="co">-- | Expects a character satisfying the given predicate.</span></a>
<a class="sourceLine" id="cb21-2" data-line-number="2">satisfies</a>
<a class="sourceLine" id="cb21-3" data-line-number="3"><span class="ot">  ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">=&gt;</span> (t <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  <span class="ot">-&gt;</span> <span class="dt">String</span>         <span class="co">-- ^ Human-readable name for</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">                    <span class="co">--   the class of recognized tokens.</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> t t</a>
<a class="sourceLine" id="cb21-8" data-line-number="8">satisfies p msg <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \_ stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  <span class="kw">case</span> popToken stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">      (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedEOF</span> (<span class="dt">Left</span> msg))</a>
<a class="sourceLine" id="cb21-12" data-line-number="12"></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">    <span class="dt">Just</span> (a,pos,rest) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">      <span class="kw">if</span> p a</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        <span class="kw">then</span> (<span class="dt">Consumed</span> pos pos, <span class="dt">Right</span> (a, rest))</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        <span class="kw">else</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedSatisfy</span> a msg pos)</a>
<a class="sourceLine" id="cb21-17" data-line-number="17"></a>
<a class="sourceLine" id="cb21-18" data-line-number="18"><span class="co">-- | Expects any character.</span></a>
<a class="sourceLine" id="cb21-19" data-line-number="19"><span class="ot">anyToken ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t t</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">anyToken <span class="fu">=</span> satisfies (const <span class="dt">True</span>) <span class="st">&quot;any token&quot;</span></a></code></pre></div>
<p>We can also define PEG-style positive and negative lookahead combinators; these allow for speculative parsing.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1"><span class="co">-- | @wouldFail p@ succeeds if and only if @p@ fails (whether</span></a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="co">--   or not @p@ consumes input), but does not consume any input.</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3"><span class="ot">wouldFail ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t ()</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">wouldFail (<span class="dt">Parser</span> q) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6">    (_,r) <span class="fu">=</span> q ref stream</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    h <span class="fu">=</span> <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-8" data-line-number="8">      <span class="dt">Left</span> _  <span class="ot">-&gt;</span> <span class="dt">Right</span> ((), stream)</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">      <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span> <span class="dt">UnexpectedSuccess</span> (pointer stream)</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">  <span class="kw">in</span> (<span class="dt">Declined</span>, h)</a>
<a class="sourceLine" id="cb22-11" data-line-number="11"></a>
<a class="sourceLine" id="cb22-12" data-line-number="12"><span class="co">-- | @wouldSucceed p@ succeeds if and only if @p@ succeeds, (whether</span></a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="co">--   or not @p@ consumes input), but does not consume any input.</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14"><span class="ot">wouldSucceed ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t ()</a>
<a class="sourceLine" id="cb22-15" data-line-number="15">wouldSucceed (<span class="dt">Parser</span> q) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb22-17" data-line-number="17">    (_,r) <span class="fu">=</span> q ref stream</a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    h <span class="fu">=</span> <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-19" data-line-number="19">      <span class="dt">Right</span> _ <span class="ot">-&gt;</span> <span class="dt">Right</span> ((), stream)</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">      <span class="dt">Left</span> e  <span class="ot">-&gt;</span> <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Because</span> (<span class="dt">Lookahead</span> (pointer stream)) e</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">  <span class="kw">in</span> (<span class="dt">Declined</span>, h)</a></code></pre></div>
<h2 id="simple-tokens">Simple Tokens</h2>
<p>We’ve now more or less got a basic parser combinator library. But before we can actually use it we need an instance of <code>Token</code> – for basic use we’ll define instances for <code>Char</code> (for text) and <code>Word8</code> (for binary data).</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Token</span> <span class="dt">Char</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  updatePos c (<span class="dt">Pos</span> ln col) <span class="fu">=</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3">    <span class="kw">if</span> c <span class="fu">==</span> <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">      <span class="kw">then</span> <span class="dt">Pos</span> (ln<span class="fu">+</span><span class="dv">1</span>) <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">      <span class="kw">else</span> <span class="dt">Pos</span> ln (col<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb23-6" data-line-number="6"></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">  initPos <span class="fu">=</span> <span class="dt">Pos</span> <span class="dv">1</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"></a>
<a class="sourceLine" id="cb23-9" data-line-number="9">  formatPos (<span class="dt">Pos</span> ln col) <span class="fu">=</span> concat</a>
<a class="sourceLine" id="cb23-10" data-line-number="10">    [ <span class="st">&quot;l&quot;</span>, show ln, <span class="st">&quot;c&quot;</span>, show col ]</a></code></pre></div>
<p>Some <code>Char</code> specific parsers:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="co">-- | Expects the given character.</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2"><span class="ot">char ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3">char <span class="fu">=</span> token</a>
<a class="sourceLine" id="cb24-4" data-line-number="4"></a>
<a class="sourceLine" id="cb24-5" data-line-number="5"><span class="co">-- | Expects a newline character.</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6"><span class="ot">newline ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">newline <span class="fu">=</span> char <span class="ch">&#39;\n&#39;</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8"></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="co">-- | Expects zero or more space characters.</span></a>
<a class="sourceLine" id="cb24-10" data-line-number="10"><span class="ot">spaces ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">spaces <span class="fu">=</span> many <span class="fu">$</span> char <span class="ch">&#39; &#39;</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12"></a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="co">-- | Expects a character in the range @[&#39;0&#39;..&#39;9&#39;]@.</span></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="ot">decimalDigit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">decimalDigit <span class="fu">=</span> satisfies</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">  (\c <span class="ot">-&gt;</span> elem c <span class="st">&quot;0123456789&quot;</span>)</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">  <span class="st">&quot;decimal digit (0-9)&quot;</span></a>
<a class="sourceLine" id="cb24-18" data-line-number="18"></a>
<a class="sourceLine" id="cb24-19" data-line-number="19"><span class="co">-- | Expects a hexadecimal digit (0-9, a-f, A-F)</span></a>
<a class="sourceLine" id="cb24-20" data-line-number="20"><span class="ot">hexDigit ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-21" data-line-number="21">hexDigit <span class="fu">=</span> satisfies</a>
<a class="sourceLine" id="cb24-22" data-line-number="22">  (\c <span class="ot">-&gt;</span> elem c <span class="st">&quot;0123456789abcdefABCDEF&quot;</span>)</a>
<a class="sourceLine" id="cb24-23" data-line-number="23">  <span class="st">&quot;hexadecimal digit (0-9, a-f, A-F)&quot;</span></a>
<a class="sourceLine" id="cb24-24" data-line-number="24"></a>
<a class="sourceLine" id="cb24-25" data-line-number="25"><span class="co">-- | Expects a character in the range @[&#39;a&#39;..&#39;z&#39;]@.</span></a>
<a class="sourceLine" id="cb24-26" data-line-number="26"><span class="ot">lowerLatin ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-27" data-line-number="27">lowerLatin <span class="fu">=</span> satisfies</a>
<a class="sourceLine" id="cb24-28" data-line-number="28">  (\c <span class="ot">-&gt;</span> elem c <span class="st">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>)</a>
<a class="sourceLine" id="cb24-29" data-line-number="29">  <span class="st">&quot;lower case latin letter (a-z)&quot;</span></a>
<a class="sourceLine" id="cb24-30" data-line-number="30"></a>
<a class="sourceLine" id="cb24-31" data-line-number="31"><span class="co">-- | Expects a character in the range @[&#39;A&#39;..&#39;Z&#39;]@.</span></a>
<a class="sourceLine" id="cb24-32" data-line-number="32"><span class="ot">upperLatin ::</span> <span class="dt">Parser</span> <span class="dt">Char</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-33" data-line-number="33">upperLatin <span class="fu">=</span> satisfies</a>
<a class="sourceLine" id="cb24-34" data-line-number="34">  (\c <span class="ot">-&gt;</span> elem c <span class="st">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>)</a>
<a class="sourceLine" id="cb24-35" data-line-number="35">  <span class="st">&quot;upper case latin letter (A-Z)&quot;</span></a></code></pre></div>
<p>For fun:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Token</span> <span class="dt">Word8</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  updatePos _ (<span class="dt">Pos</span> _ offset) <span class="fu">=</span> <span class="dt">Pos</span> <span class="dv">0</span> (offset <span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb25-3" data-line-number="3"></a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  initPos <span class="fu">=</span> <span class="dt">Pos</span> <span class="dv">0</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5"></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  formatPos (<span class="dt">Pos</span> _ offset) <span class="fu">=</span> unwords</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    [ <span class="st">&quot;offset&quot;</span>, <span class="ch">&#39;0&#39;</span> <span class="fu">:</span> <span class="ch">&#39;x&#39;</span> <span class="fu">:</span> showHex offset <span class="st">&quot;&quot;</span> ]</a></code></pre></div>
<h2 id="derived-combinators">Derived Combinators</h2>
<p>Several handy combinators can be defined in terms of the applicative and monad interfaces.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- | Tries the argument parsers one at a time in order,</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="co">--   backtracking on failure. Returns the value of the</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="co">--   first succeeding parser.</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="ot">choice ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> [<span class="dt">Parser</span> t a] <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">choice ps <span class="fu">=</span> foldr (<span class="fu">&lt;|&gt;</span>) empty ps</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="co">-- | One or more @p@, separated by @sep@.</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8"><span class="ot">someSepBy ::</span> <span class="dt">Parser</span> t u <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t [a]</a>
<a class="sourceLine" id="cb26-9" data-line-number="9">someSepBy sep p <span class="fu">=</span> (<span class="fu">:</span>) <span class="fu">&lt;$&gt;</span> p <span class="fu">&lt;*&gt;</span> many (sep <span class="fu">&gt;&gt;</span> p)</a>
<a class="sourceLine" id="cb26-10" data-line-number="10"></a>
<a class="sourceLine" id="cb26-11" data-line-number="11"><span class="co">-- | Zero or more @p@, separated by @sep@.</span></a>
<a class="sourceLine" id="cb26-12" data-line-number="12"><span class="ot">manySepBy ::</span> <span class="dt">Parser</span> t u <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t [a]</a>
<a class="sourceLine" id="cb26-13" data-line-number="13">manySepBy sep p <span class="fu">=</span> (someSepBy sep p) <span class="fu">&lt;|&gt;</span> return [] </a></code></pre></div>
<h2 id="indentation">Indentation</h2>
<p>Recall that every parser runs in the context of a special <code>Pos</code> value called the <em>reference position</em>. Now we will define some primitive combinators that affect the behavior of parsers using this value.</p>
<p>First off, since the reference position is a reader context, we should have combinators for getting its value and making local changes: <code>readRef</code> gets the value of the reference position, <code>adjustRef</code> applies an arbitrary function to the reference in a context, and <code>localRef</code> sets it to a specific value in a context. Note that the scope of these changes is strictly limited.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="co">-- | Returns the current reference position.</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">readRef ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t (<span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">readRef <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span> (<span class="dt">Declined</span>, <span class="dt">Right</span> (ref, stream))</a>
<a class="sourceLine" id="cb27-4" data-line-number="4"></a>
<a class="sourceLine" id="cb27-5" data-line-number="5"><span class="co">-- | Apply a function to the reference position, and run</span></a>
<a class="sourceLine" id="cb27-6" data-line-number="6"><span class="co">--   a parser in that context.</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7"><span class="ot">adjustRef ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> (<span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">Pos</span> t) <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb27-8" data-line-number="8">adjustRef f (<span class="dt">Parser</span> p) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span> p (f ref) stream</a>
<a class="sourceLine" id="cb27-9" data-line-number="9"></a>
<a class="sourceLine" id="cb27-10" data-line-number="10"><span class="co">-- | Set the reference position to a given value, and run</span></a>
<a class="sourceLine" id="cb27-11" data-line-number="11"><span class="co">--   a parser in that context.</span></a>
<a class="sourceLine" id="cb27-12" data-line-number="12"><span class="ot">localRef ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb27-13" data-line-number="13">localRef <span class="fu">=</span> adjustRef <span class="fu">.</span> const</a></code></pre></div>
<p>Next it will be handy to have a combinator that returns the consumed range of characters. Thinking of <code>DidConsume</code> as the log monoid for the <code>Writer</code> monad pattern, this is analogous to the standard <code>listen</code> function, with one exception: <code>consume p</code> should fail if <code>p</code> declines to consume characters.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="co">-- | Run a parser against the stream, and return the consumed</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="co">--   range with the result. Fails if the parser declines to</span></a>
<a class="sourceLine" id="cb28-3" data-line-number="3"><span class="co">--   consume any input.</span></a>
<a class="sourceLine" id="cb28-4" data-line-number="4"><span class="ot">consume ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t (a, (<span class="dt">Pos</span> t, <span class="dt">Pos</span> t))</a>
<a class="sourceLine" id="cb28-5" data-line-number="5">consume (<span class="dt">Parser</span> p) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">  <span class="kw">let</span> (c,r) <span class="fu">=</span> p ref stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-7" data-line-number="7">  <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">    <span class="dt">Declined</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9">      <span class="kw">let</span> pos <span class="fu">=</span> pointer stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb28-10" data-line-number="10">      <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-11" data-line-number="11">        <span class="dt">Right</span> _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12">          (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">            <span class="dt">UnexpectedDecline</span> pos)</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">        <span class="dt">Left</span> err <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">          (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Because</span> (<span class="dt">DeclineReason</span> pos) err)</a>
<a class="sourceLine" id="cb28-16" data-line-number="16"></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">    <span class="dt">Consumed</span> u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb28-19" data-line-number="19">        h <span class="fu">=</span> <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-20" data-line-number="20">          <span class="dt">Left</span> err <span class="ot">-&gt;</span> <span class="dt">Left</span> err</a>
<a class="sourceLine" id="cb28-21" data-line-number="21">          <span class="dt">Right</span> (a, rest) <span class="ot">-&gt;</span> <span class="dt">Right</span> ((a, (u1, u2)), rest)</a>
<a class="sourceLine" id="cb28-22" data-line-number="22">        <span class="kw">in</span> (<span class="dt">Consumed</span> u1 u2, h)</a></code></pre></div>
<p>Similarly useful is a combinator that forces a parser to report that it did not consume any characters, even if it did alter the stream. This is useful for removing whitespace from the stream without reporting it as “consumed”. Compare <code>ignore</code> to <code>lookahead</code>: both run a parser and report no characters consumed, but <code>lookahead</code> returns the original stream while <code>ignore</code> returns the altered stream.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="co">-- | Run a parser against the stream, and if it succeeds,</span></a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="co">--   report success but do not report the consumed range.</span></a>
<a class="sourceLine" id="cb29-3" data-line-number="3"><span class="ot">ignore ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t ()</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">ignore (<span class="dt">Parser</span> q) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5">  <span class="kw">case</span> q ref stream <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-6" data-line-number="6">    (_, <span class="dt">Left</span> err)       <span class="ot">-&gt;</span> (<span class="dt">Declined</span>, <span class="dt">Left</span> err)</a>
<a class="sourceLine" id="cb29-7" data-line-number="7">    (_, <span class="dt">Right</span> (_,rest)) <span class="ot">-&gt;</span> (<span class="dt">Declined</span>, <span class="dt">Right</span> ((), rest))</a></code></pre></div>
<p>Recall that a parser is indentation sensitive if, when it consumes characters, there is a predicate that must be satisfied by the reference position and the range of consumed characters in order for the parse to be valid. To impose some discipline on this, we’ll wrap this predicate in a type with a human-readable error message.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co">-- | Represents an indentation strategy.</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Indentation</span> t <span class="fu">=</span> <span class="dt">Indentation</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  {<span class="ot"> relation ::</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> (<span class="dt">Pos</span> t, <span class="dt">Pos</span> t) <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4">    <span class="co">-- ^ True if the consumed range is valid with respect</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5">    <span class="co">--   to the reference position.</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"></a>
<a class="sourceLine" id="cb30-7" data-line-number="7">  ,<span class="ot"> message ::</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> (<span class="dt">Pos</span> t, <span class="dt">Pos</span> t) <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8">    <span class="co">-- ^ Human-readable error message for when the</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9">    <span class="co">--   indentation is invalid.</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10">  }</a></code></pre></div>
<p>Now the fundamental combinator for building indentation sensitive parsers, <code>indent</code>, simply applies this predicate to the result of a successful parse result.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="co">-- | Run a parser and, if it succeeds, verify that the</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="co">--   consumed range satisfies the given indentation.</span></a>
<a class="sourceLine" id="cb31-3" data-line-number="3">indent</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"><span class="ot">  ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">  <span class="ot">=&gt;</span> <span class="dt">Indentation</span> t</a>
<a class="sourceLine" id="cb31-6" data-line-number="6">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb31-7" data-line-number="7">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb31-8" data-line-number="8">indent ind (<span class="dt">Parser</span> q) <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \ref stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">  <span class="kw">let</span> (c, r) <span class="fu">=</span> q ref stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb31-10" data-line-number="10">  <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-11" data-line-number="11">    <span class="dt">Declined</span> <span class="ot">-&gt;</span> (c, r)</a>
<a class="sourceLine" id="cb31-12" data-line-number="12">    <span class="dt">Consumed</span> u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-13" data-line-number="13">      <span class="kw">case</span> r <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-14" data-line-number="14">        <span class="dt">Left</span> _ <span class="ot">-&gt;</span> (c, r)</a>
<a class="sourceLine" id="cb31-15" data-line-number="15">        <span class="dt">Right</span> _ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-16" data-line-number="16">          <span class="kw">if</span> relation ind ref (u1,u2)</a>
<a class="sourceLine" id="cb31-17" data-line-number="17">            <span class="kw">then</span> (c, r)</a>
<a class="sourceLine" id="cb31-18" data-line-number="18">            <span class="kw">else</span> ( <span class="dt">Declined</span></a>
<a class="sourceLine" id="cb31-19" data-line-number="19">                 , <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Simply</span> <span class="fu">$</span></a>
<a class="sourceLine" id="cb31-20" data-line-number="20">                     <span class="dt">UnexpectedIndentation</span></a>
<a class="sourceLine" id="cb31-21" data-line-number="21">                       (message ind ref (u1,u2)) (u1, u2)</a>
<a class="sourceLine" id="cb31-22" data-line-number="22">                 )</a></code></pre></div>
<p>Constructing <code>Indentation</code> values is not difficult, but a little tedious; later on we’ll make a little built-in DSL for handling the most common cases.</p>
<h2 id="errors">Errors</h2>
<p>The basic combinators can do an okay job of reporting useful errors as-is. But the Parsec authors go one step further to provide an explicit error message combinator, which gives much finer control over semantic errors. The <code>&lt;?&gt;</code> function tries to run a parser, and if it fails, gives a higher level error message.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1"><span class="co">-- | Run a parser, and on failure, attach an error message.</span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot">(&lt;?&gt;) ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb32-3" data-line-number="3">(<span class="dt">Parser</span> q) <span class="fu">&lt;?&gt;</span> msg <span class="fu">=</span> <span class="dt">Parser</span> <span class="fu">$</span> \stack stream <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-4" data-line-number="4">  <span class="kw">let</span> (c, result) <span class="fu">=</span> q stack stream <span class="kw">in</span></a>
<a class="sourceLine" id="cb32-5" data-line-number="5">    <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6">      <span class="dt">Right</span> value <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7">        (<span class="dt">Declined</span>, <span class="dt">Right</span> value)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8">      <span class="dt">Left</span> err <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">        (<span class="dt">Declined</span>, <span class="dt">Left</span> <span class="fu">$</span> <span class="dt">Because</span> (<span class="dt">Note</span> msg (pointer stream)) err)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10"></a>
<a class="sourceLine" id="cb32-11" data-line-number="11">infix <span class="dv">0</span> <span class="fu">&lt;?&gt;</span></a></code></pre></div>
<p>For example, we can use <code>&lt;?&gt;</code> with <code>mapM</code> and <code>char</code> to parse specific strings with a better error message.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1"><span class="ot">string ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">Char</span> ()</a>
<a class="sourceLine" id="cb33-2" data-line-number="2">string str <span class="fu">=</span> mapM_ char str <span class="fu">&lt;?&gt;</span> str</a></code></pre></div>
<p>So far we’ve glossed over the details of the <code>ParseError</code> type, but now it’s time to unpack that. The purpose of an error type for a parser is to give human users relevant information about what went wrong. At the same time, we don’t want to expect readers of the errors to know how this parsing library works, since in practice they’ll be using some other tool and shouldn’t need to care what parsing library it used.</p>
<p>Our errors so far have been pretty simple. We have some <em>basic</em> errors, including those about unexpected characters and indentation. We also have a couple of <em>compound</em> errors, like the unexplained <code>Because</code> and <code>OneOf</code> and whatever is happening inside the implementation of <code>&lt;|&gt;</code>. The compound errors come in two flavors. In <code>&lt;|&gt;</code> we have two errors and want to report that both occurred; this takes two errors and mushes them into one. In <code>&lt;?&gt;</code> and <code>wouldSucceed</code> we have an error but want to annotate it with some extra information. This takes an error and an annotation and produces an error.</p>
<p>This looks like a free algebra, in the universal algebra sense. We have a set of atoms (the basic errors) and some operations (mushing and annotation) and want to construct the “smallest” type that is closed under them. Assume for the moment that “mushing” (combining errors as in <code>&lt;|&gt;</code>) has to be associative – which it does, by the alternative functor laws. Then what we have is a free monoid on the basic errors (under mush) being acted on freely by the set of annotations. (!!!)</p>
<p>We can model this algebra with the following type; <code>a</code> is the type of annotations and <code>e</code> the type of basic errors.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">-- | Structured error type.</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="kw">data</span> <span class="dt">Error</span> a e</a>
<a class="sourceLine" id="cb34-3" data-line-number="3">  <span class="fu">=</span> <span class="dt">OneOf</span> [<span class="dt">Error</span> a e]     <span class="co">-- ^ List of failure reasons</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Because</span> a (<span class="dt">Error</span> a e) <span class="co">-- ^ Annotated failure</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Simply</span> e              <span class="co">-- ^ Simple failure</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>We can make <code>Error a e</code> a monoid, where <code>OneOf []</code> is the identity. Multiplication is <em>almost</em> concatenation; recall that the free monoid on <code>a</code> is the type of lists of <code>a</code>, and multiplication is just concat. The annotations make this a little more complicated for <code>Error a e</code>.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="co">-- | @Error a e@ is a free monoid over @e@ being acted on</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="co">--   freely by @a@.</span></a>
<a class="sourceLine" id="cb35-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Semigroup</span> (<span class="dt">Error</span> a e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  (<span class="dt">OneOf</span> es1) <span class="fu">&lt;&gt;</span> (<span class="dt">OneOf</span> es2) <span class="fu">=</span> <span class="dt">OneOf</span> (es1 <span class="fu">++</span> es2)</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">  (<span class="dt">OneOf</span> es1) <span class="fu">&lt;&gt;</span> y           <span class="fu">=</span> <span class="kw">case</span> es1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">                                 [] <span class="ot">-&gt;</span> y</a>
<a class="sourceLine" id="cb35-7" data-line-number="7">                                 _  <span class="ot">-&gt;</span> <span class="dt">OneOf</span> <span class="fu">$</span> es1 <span class="fu">++</span> [y]</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">  x           <span class="fu">&lt;&gt;</span> (<span class="dt">OneOf</span> es2) <span class="fu">=</span> <span class="kw">case</span> es2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-9" data-line-number="9">                                 [] <span class="ot">-&gt;</span> x</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">                                 _  <span class="ot">-&gt;</span> <span class="dt">OneOf</span> <span class="fu">$</span> [x] <span class="fu">++</span> es2</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">  x           <span class="fu">&lt;&gt;</span> y           <span class="fu">=</span> <span class="dt">OneOf</span> [x,y]</a>
<a class="sourceLine" id="cb35-12" data-line-number="12"></a>
<a class="sourceLine" id="cb35-13" data-line-number="13"><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">Error</span> a e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-14" data-line-number="14">  mempty  <span class="fu">=</span> <span class="dt">OneOf</span> []</a>
<a class="sourceLine" id="cb35-15" data-line-number="15">  mappend <span class="fu">=</span> (<span class="fu">&lt;&gt;</span>)</a></code></pre></div>
<p>Now the basic errors are just a roster of the bad things that can happen when we pop a <code>Char</code> from the stream, or look at the reference position (to be discussed later).</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1"><span class="co">-- | Low-level reasons why a parse can fail.</span></a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="kw">data</span> <span class="dt">BasicError</span> t</a>
<a class="sourceLine" id="cb36-3" data-line-number="3">  <span class="fu">=</span> <span class="dt">UnexpectedEOF</span> (<span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">Maybe</span> t))</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">UnexpectedToken</span> t (<span class="dt">Maybe</span> t) (<span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">UnexpectedSatisfy</span> t <span class="dt">String</span> (<span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb36-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">UnexpectedIndentation</span> <span class="dt">String</span> (<span class="dt">Pos</span> t, <span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb36-7" data-line-number="7">  <span class="fu">|</span> <span class="dt">UnexpectedSuccess</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">  <span class="fu">|</span> <span class="dt">UnexpectedDecline</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">  <span class="fu">|</span> <span class="dt">ExpectedBOF</span> (<span class="dt">Pos</span> t)</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">  <span class="fu">|</span> <span class="dt">IncompleteParse</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))</a>
<a class="sourceLine" id="cb36-11" data-line-number="11">  <span class="fu">|</span> <span class="dt">Failure</span> <span class="dt">String</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))</a>
<a class="sourceLine" id="cb36-12" data-line-number="12">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Our annotations come in a couple of flavors.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1"><span class="co">-- | Represents a reason why a parse failed, above</span></a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="co">--   the level of unexpected character or EOF.</span></a>
<a class="sourceLine" id="cb37-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Annotation</span> t</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">Note</span> <span class="dt">String</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))   <span class="co">-- ^ Comes from @\&lt;?&gt;@</span></a>
<a class="sourceLine" id="cb37-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Lookahead</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t))     <span class="co">-- ^ Comes from @wouldFail@</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="fu">|</span> <span class="dt">DeclineReason</span> (<span class="dt">Maybe</span> (<span class="dt">Pos</span> t)) <span class="co">-- ^ Comes from @consume@</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>So the <code>ParseError</code> type looks like this:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co">-- | Synonym for the type of trees of parse errors.</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="kw">type</span> <span class="dt">ParseError</span> t <span class="fu">=</span> <span class="dt">Error</span> (<span class="dt">Annotation</span> t) (<span class="dt">BasicError</span> t)</a></code></pre></div>
<p><code>ParseError</code> values are essentially trees, and this structure means they can be very precise.</p>
<h2 id="permutation-phrases">Permutation Phrases</h2>
<p>A <em>permutation phrase</em> is a list of words that can be in any order without changing the meaning of the phrase. These phrases are interesting for parsers because they show up in lots of places – command line arguments, JSON data, and HTML attributes are three examples – but can be awkward to handle. The paper <em>Parsing Permutation Phrases</em> has a very nice approach to parsing permutation phrases with combinators, and can even deal with optional items. We’ll follow along with that paper and with its implementation in Parsec to get similar functionality here. The amount of code needed to do this is surprisingly small, though it does use the <code>ExistentialQuantification</code> language extension.</p>
<p>This approach uses a tree of all possible orderings of a list of parsers, which is exponential in size, but uses lazy evaluation to aggressively prune this tree so that only a quadratic amount of it is actually constructed.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1"><span class="co">-- | Opaque type representing a parser for permutation</span></a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="co">--   phrases. To construct values of this type, see</span></a>
<a class="sourceLine" id="cb39-3" data-line-number="3"><span class="co">--   @\&lt;$$&gt;@, @\&lt;$?&gt;@, @\&lt;&amp;&amp;&gt;@, and @\&lt;&amp;?&gt;@.</span></a>
<a class="sourceLine" id="cb39-4" data-line-number="4"><span class="kw">data</span> <span class="dt">Perms</span> t a</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">  <span class="fu">=</span> <span class="dt">Perms</span> (<span class="dt">Maybe</span> a) [<span class="dt">Branch</span> t a]</a>
<a class="sourceLine" id="cb39-6" data-line-number="6"></a>
<a class="sourceLine" id="cb39-7" data-line-number="7"><span class="kw">data</span> <span class="dt">Branch</span> t a</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">  <span class="fu">=</span> forall x<span class="fu">.</span> <span class="dt">Branch</span> (<span class="dt">Perms</span> t (x <span class="ot">-&gt;</span> a)) (<span class="dt">Parser</span> t x)</a>
<a class="sourceLine" id="cb39-9" data-line-number="9"></a>
<a class="sourceLine" id="cb39-10" data-line-number="10"><span class="ot">perm ::</span> a <span class="ot">-&gt;</span> <span class="dt">Perms</span> t a</a>
<a class="sourceLine" id="cb39-11" data-line-number="11">perm a <span class="fu">=</span> <span class="dt">Perms</span> (<span class="dt">Just</span> a) []</a></code></pre></div>
<p>I’m 95% sure these <code>Functor</code> instances are legitimate, although the Parsec authors use ad-hoc functions instead of <code>fmap</code>. I’m not sure why.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Perms</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2">  fmap f (<span class="dt">Perms</span> x xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3">    <span class="dt">Perms</span> (fmap f x) (map (fmap f) xs)</a>
<a class="sourceLine" id="cb40-4" data-line-number="4"></a>
<a class="sourceLine" id="cb40-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Branch</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6">  fmap f (<span class="dt">Branch</span> t p) <span class="fu">=</span> <span class="dt">Branch</span> (fmap (f <span class="fu">.</span>) t) p</a></code></pre></div>
<p>We have a mini-DSL for building permutation parsers consisting of four combinators: <code>&lt;$$&gt;</code>, <code>&lt;$?&gt;</code>, <code>&lt;&amp;&amp;&gt;</code>, and <code>&lt;&amp;?&gt;</code>. To use these we need a single function accepting one or more arguments that we want to parse in any order. Then we list out the parsers for each argument, prefixing with <code>&lt;&amp;&amp;&gt;</code> (if the argument is required) or <code>&lt;&amp;?&gt;</code> (if the argument is optional). The first argument is prefixed with <code>&lt;$$&gt;</code> or <code>&lt;$?&gt;</code>. (This sort of mimics the <code>Applicative</code> style.)</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="co">-- | Append a required term to a permutation phrase.</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="ot">(&lt;&amp;&amp;&gt;) ::</span> <span class="dt">Perms</span> t (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b</a>
<a class="sourceLine" id="cb41-3" data-line-number="3">t<span class="fu">@</span>(<span class="dt">Perms</span> u bs) <span class="fu">&lt;&amp;&amp;&gt;</span> p <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-4" data-line-number="4">  <span class="dt">Perms</span> <span class="dt">Nothing</span> <span class="fu">$</span> (<span class="dt">Branch</span> t p) <span class="fu">:</span> map insert bs</a>
<a class="sourceLine" id="cb41-5" data-line-number="5">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">      insert (<span class="dt">Branch</span> w q) <span class="fu">=</span> <span class="dt">Branch</span> ((fmap flip w) <span class="fu">&lt;&amp;&amp;&gt;</span> p) q</a>
<a class="sourceLine" id="cb41-7" data-line-number="7"></a>
<a class="sourceLine" id="cb41-8" data-line-number="8"><span class="co">-- | Start a permutation phrase with a required term.</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9"><span class="ot">(&lt;$$&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">f <span class="fu">&lt;$$&gt;</span> p <span class="fu">=</span> perm f <span class="fu">&lt;&amp;&amp;&gt;</span> p</a>
<a class="sourceLine" id="cb41-11" data-line-number="11"></a>
<a class="sourceLine" id="cb41-12" data-line-number="12"><span class="co">-- | Append an optional term to a permutation phrase.</span></a>
<a class="sourceLine" id="cb41-13" data-line-number="13"><span class="ot">(&lt;&amp;?&gt;) ::</span> <span class="dt">Perms</span> t (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a, <span class="dt">Parser</span> t a) <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b</a>
<a class="sourceLine" id="cb41-14" data-line-number="14">t<span class="fu">@</span>(<span class="dt">Perms</span> u bs) <span class="fu">&lt;&amp;?&gt;</span> (x,p) <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-15" data-line-number="15">  <span class="dt">Perms</span> (fmap (<span class="fu">$</span> x) u) <span class="fu">$</span> (<span class="dt">Branch</span> t p) <span class="fu">:</span> map insert bs</a>
<a class="sourceLine" id="cb41-16" data-line-number="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-17" data-line-number="17">      insert (<span class="dt">Branch</span> w q) <span class="fu">=</span> <span class="dt">Branch</span> ((fmap flip w) <span class="fu">&lt;&amp;?&gt;</span> (x,p)) q</a>
<a class="sourceLine" id="cb41-18" data-line-number="18"></a>
<a class="sourceLine" id="cb41-19" data-line-number="19"><span class="co">-- | Start a permutation phrase with an optional term.</span></a>
<a class="sourceLine" id="cb41-20" data-line-number="20"><span class="ot">(&lt;$?&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a, <span class="dt">Parser</span> t a) <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b</a>
<a class="sourceLine" id="cb41-21" data-line-number="21">f <span class="fu">&lt;$?&gt;</span> (x,p) <span class="fu">=</span> perm f <span class="fu">&lt;&amp;?&gt;</span> (x,p)</a>
<a class="sourceLine" id="cb41-22" data-line-number="22"></a>
<a class="sourceLine" id="cb41-23" data-line-number="23"><span class="kw">infixl</span> <span class="dv">1</span> <span class="fu">&lt;&amp;&amp;&gt;</span>, <span class="fu">&lt;&amp;?&gt;</span></a>
<a class="sourceLine" id="cb41-24" data-line-number="24"><span class="kw">infixl</span> <span class="dv">2</span> <span class="fu">&lt;$$&gt;</span>, <span class="fu">&lt;$?&gt;</span></a></code></pre></div>
<p>Once we’ve constructed a permutation phrase, we can convert it to a normal parser with <code>permute</code>.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1"><span class="co">-- | Convert a permutation phrase to a @Parser@.</span></a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="ot">permute ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Perms</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">permute (<span class="dt">Perms</span> u bs) <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-5" data-line-number="5">    nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb42-7" data-line-number="7">      <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb42-8" data-line-number="8"></a>
<a class="sourceLine" id="cb42-9" data-line-number="9">    branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb42-10" data-line-number="10">      x <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb42-11" data-line-number="11">      f <span class="ot">&lt;-</span> permute w</a>
<a class="sourceLine" id="cb42-12" data-line-number="12">      return (f x)</a></code></pre></div>
<p>Another common situation is that we want terms to be permutable but also separated by a fixed delimiter, like a comma. I’m pretty sure we can’t do this in terms of <code>permute</code> and the other combinators, so we’ll provide a combinator for it here.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1"><span class="co">-- | Convert a permutation phrase to a @Parser@, with</span></a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="co">--   terms separated by @psep@.</span></a>
<a class="sourceLine" id="cb43-3" data-line-number="3"><span class="ot">permuteSepBy ::</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Perms</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">permuteSepBy <span class="fu">=</span> psep (pure ())</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6">    psep</a>
<a class="sourceLine" id="cb43-7" data-line-number="7"><span class="ot">      ::</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">      <span class="ot">=&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Perms</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb43-9" data-line-number="9">    psep init sep (<span class="dt">Perms</span> u bs)</a>
<a class="sourceLine" id="cb43-10" data-line-number="10">      <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb43-11" data-line-number="11">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-12" data-line-number="12">        nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-13" data-line-number="13">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">          <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb43-15" data-line-number="15"></a>
<a class="sourceLine" id="cb43-16" data-line-number="16">        branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb43-17" data-line-number="17">          init</a>
<a class="sourceLine" id="cb43-18" data-line-number="18">          x <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">          f <span class="ot">&lt;-</span> psep sep sep w</a>
<a class="sourceLine" id="cb43-20" data-line-number="20">          return (f x)</a></code></pre></div>
<p>Likewise there are cases where the indentation of items 2 through n in the permuted list depend on the indentation of item 1. For instance, the items in the list should be indented to the same column, but we don’t know <em>which</em> column until the first item is parsed. We can’t do this in terms of <code>permute</code> and the other combinators, so we’ll provide it here.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1"><span class="co">-- | Convert a permutation phrase to a @Parser@, with</span></a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="co">--   all terms indented with respect to the start</span></a>
<a class="sourceLine" id="cb44-3" data-line-number="3"><span class="co">--   position of the first.</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">permuteIndent</a>
<a class="sourceLine" id="cb44-5" data-line-number="5"><span class="ot">  ::</span> forall t a<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb44-6" data-line-number="6">  <span class="ot">=&gt;</span> <span class="dt">Indentation</span> t <span class="ot">-&gt;</span> <span class="dt">Perms</span> t a <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">permuteIndent ind <span class="fu">=</span> pind</a>
<a class="sourceLine" id="cb44-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-9" data-line-number="9">    pind</a>
<a class="sourceLine" id="cb44-10" data-line-number="10"><span class="ot">      ::</span> forall b<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb44-11" data-line-number="11">      <span class="ot">=&gt;</span> <span class="dt">Perms</span> t b <span class="ot">-&gt;</span> <span class="dt">Parser</span> t b</a>
<a class="sourceLine" id="cb44-12" data-line-number="12">    pind (<span class="dt">Perms</span> u bs)</a>
<a class="sourceLine" id="cb44-13" data-line-number="13">      <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb44-14" data-line-number="14">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-15" data-line-number="15">        nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-16" data-line-number="16">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb44-17" data-line-number="17">          <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb44-18" data-line-number="18"></a>
<a class="sourceLine" id="cb44-19" data-line-number="19">        branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb44-20" data-line-number="20">          (x,(u,_)) <span class="ot">&lt;-</span> consume p</a>
<a class="sourceLine" id="cb44-21" data-line-number="21">          f <span class="ot">&lt;-</span> localRef u <span class="fu">$</span> indent ind <span class="fu">$</span> pind2 w</a>
<a class="sourceLine" id="cb44-22" data-line-number="22">          return (f x)</a>
<a class="sourceLine" id="cb44-23" data-line-number="23"></a>
<a class="sourceLine" id="cb44-24" data-line-number="24">    pind2</a>
<a class="sourceLine" id="cb44-25" data-line-number="25"><span class="ot">      ::</span> forall b<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb44-26" data-line-number="26">      <span class="ot">=&gt;</span> <span class="dt">Perms</span> t b <span class="ot">-&gt;</span> <span class="dt">Parser</span> t b</a>
<a class="sourceLine" id="cb44-27" data-line-number="27">    pind2 (<span class="dt">Perms</span> u bs)</a>
<a class="sourceLine" id="cb44-28" data-line-number="28">      <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb44-29" data-line-number="29">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb44-30" data-line-number="30">        nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-31" data-line-number="31">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb44-32" data-line-number="32">          <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb44-33" data-line-number="33"></a>
<a class="sourceLine" id="cb44-34" data-line-number="34">        branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb44-35" data-line-number="35">          x <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb44-36" data-line-number="36">          f <span class="ot">&lt;-</span> pind2 w</a>
<a class="sourceLine" id="cb44-37" data-line-number="37">          return (f x)</a></code></pre></div>
<p>Finally, combining indentation with an item separator.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1"><span class="co">-- | Convert a permutation phrase to a @Parser@, with</span></a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="co">--   terms separated and indented with respect to the</span></a>
<a class="sourceLine" id="cb45-3" data-line-number="3"><span class="co">--   start position of the first.</span></a>
<a class="sourceLine" id="cb45-4" data-line-number="4">permuteIndentSepBy</a>
<a class="sourceLine" id="cb45-5" data-line-number="5"><span class="ot">  ::</span> forall t a<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">  <span class="ot">=&gt;</span> <span class="dt">Indentation</span> t <span class="co">-- ^ Indentation of items 2 through n</span></a>
<a class="sourceLine" id="cb45-7" data-line-number="7">                   <span class="co">--   with respect to the start position of item 1</span></a>
<a class="sourceLine" id="cb45-8" data-line-number="8">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> t ()   <span class="co">-- ^ Separator</span></a>
<a class="sourceLine" id="cb45-9" data-line-number="9">  <span class="ot">-&gt;</span> <span class="dt">Perms</span> t a</a>
<a class="sourceLine" id="cb45-10" data-line-number="10">  <span class="ot">-&gt;</span> <span class="dt">Parser</span> t a</a>
<a class="sourceLine" id="cb45-11" data-line-number="11">permuteIndentSepBy ind <span class="fu">=</span> pindsep (pure ())</a>
<a class="sourceLine" id="cb45-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-13" data-line-number="13">    pindsep</a>
<a class="sourceLine" id="cb45-14" data-line-number="14"><span class="ot">      ::</span> forall b<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb45-15" data-line-number="15">      <span class="ot">=&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b <span class="ot">-&gt;</span> <span class="dt">Parser</span> t b</a>
<a class="sourceLine" id="cb45-16" data-line-number="16">    pindsep init sep (<span class="dt">Perms</span> u bs)</a>
<a class="sourceLine" id="cb45-17" data-line-number="17">      <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb45-18" data-line-number="18">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-19" data-line-number="19">        nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-20" data-line-number="20">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb45-21" data-line-number="21">          <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb45-22" data-line-number="22"></a>
<a class="sourceLine" id="cb45-23" data-line-number="23">        branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-24" data-line-number="24">          init</a>
<a class="sourceLine" id="cb45-25" data-line-number="25">          (x,(u,_)) <span class="ot">&lt;-</span> consume p</a>
<a class="sourceLine" id="cb45-26" data-line-number="26">          f <span class="ot">&lt;-</span> localRef u <span class="fu">$</span> indent ind <span class="fu">$</span> pindsep2 sep w</a>
<a class="sourceLine" id="cb45-27" data-line-number="27">          return (f x)</a>
<a class="sourceLine" id="cb45-28" data-line-number="28"></a>
<a class="sourceLine" id="cb45-29" data-line-number="29">    pindsep2</a>
<a class="sourceLine" id="cb45-30" data-line-number="30"><span class="ot">      ::</span> forall b<span class="fu">.</span> (<span class="dt">Token</span> t)</a>
<a class="sourceLine" id="cb45-31" data-line-number="31">      <span class="ot">=&gt;</span> <span class="dt">Parser</span> t () <span class="ot">-&gt;</span> <span class="dt">Perms</span> t b <span class="ot">-&gt;</span> <span class="dt">Parser</span> t b</a>
<a class="sourceLine" id="cb45-32" data-line-number="32">    pindsep2 sep (<span class="dt">Perms</span> u bs)</a>
<a class="sourceLine" id="cb45-33" data-line-number="33">      <span class="fu">=</span> choice <span class="fu">$</span> map branch bs <span class="fu">++</span> nil</a>
<a class="sourceLine" id="cb45-34" data-line-number="34">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-35" data-line-number="35">        nil <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-36" data-line-number="36">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb45-37" data-line-number="37">          <span class="dt">Just</span> x  <span class="ot">-&gt;</span> [return x]</a>
<a class="sourceLine" id="cb45-38" data-line-number="38"></a>
<a class="sourceLine" id="cb45-39" data-line-number="39">        branch (<span class="dt">Branch</span> w p) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb45-40" data-line-number="40">          sep</a>
<a class="sourceLine" id="cb45-41" data-line-number="41">          x <span class="ot">&lt;-</span> p</a>
<a class="sourceLine" id="cb45-42" data-line-number="42">          f <span class="ot">&lt;-</span> pindsep2 sep w</a>
<a class="sourceLine" id="cb45-43" data-line-number="43">          return (f x)</a></code></pre></div>
<p>In principle, <code>permute</code>, <code>permuteSepBy</code>, and <code>permuteIndent</code> can all be implemented in terms of <code>permuteIndentSepBy</code>, but I think to do so would obscure what’s happening.</p>
<h2 id="pretty-printing">Pretty Printing</h2>
<p>The error information reported by our parsers is pretty good – we get a nice tree structure of errors with customizable text. To give them a little more zing and pep we can pretty print the errors to be a little more readable.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co">-- | Types which can be pretty printed.</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="kw">class</span> <span class="dt">Pretty</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3"><span class="ot">  pretty ::</span> t <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"></a>
<a class="sourceLine" id="cb46-5" data-line-number="5"><span class="kw">instance</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Pos</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-6" data-line-number="6">  pretty <span class="fu">=</span> formatPos</a></code></pre></div>
<p>The <code>Pretty</code> instance for <code>Char</code> makes control characters visible; otherwise they’d be printed verbatim in the error text.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Pretty</span> <span class="dt">Char</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">  pretty c <span class="fu">=</span> <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-3" data-line-number="3">    <span class="ch">&#39;\n&#39;</span> <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\\n&#39; (newline)&quot;</span></a>
<a class="sourceLine" id="cb47-4" data-line-number="4">    <span class="ch">&#39;\t&#39;</span> <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\\t&#39; (tab)&quot;</span></a>
<a class="sourceLine" id="cb47-5" data-line-number="5">    <span class="ch">&#39;\v&#39;</span> <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\\v&#39; (vertical tab)&quot;</span></a>
<a class="sourceLine" id="cb47-6" data-line-number="6">    <span class="ch">&#39;\r&#39;</span> <span class="ot">-&gt;</span> <span class="st">&quot;&#39;\\r&#39; (carriage return)&quot;</span></a>
<a class="sourceLine" id="cb47-7" data-line-number="7">    _ <span class="ot">-&gt;</span> [<span class="ch">&#39;\&#39;&#39;</span>, c, <span class="ch">&#39;\&#39;&#39;</span>]</a></code></pre></div>
<p>We can then pretty print <code>BasicError</code>s, recalling what they mean from how they are used.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Token</span> t, <span class="dt">Pretty</span> t) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">BasicError</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-2" data-line-number="2">  pretty e <span class="fu">=</span> <span class="kw">case</span> e <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-3" data-line-number="3">    <span class="dt">UnexpectedEOF</span> z <span class="ot">-&gt;</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-4" data-line-number="4">      <span class="dt">Left</span> str <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-5" data-line-number="5">        [ <span class="st">&quot;expected&quot;</span>, str, <span class="st">&quot;but reached end of stream&quot;</span> ]</a>
<a class="sourceLine" id="cb48-6" data-line-number="6">      <span class="dt">Right</span> c <span class="ot">-&gt;</span> <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-8" data-line-number="8">          <span class="st">&quot;expected beginning of stream, but reached end of stream&quot;</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9">        <span class="dt">Just</span> w <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-10" data-line-number="10">          [ <span class="st">&quot;expected&quot;</span>, pretty w, <span class="st">&quot;but reached end of stream&quot;</span> ]</a>
<a class="sourceLine" id="cb48-11" data-line-number="11"></a>
<a class="sourceLine" id="cb48-12" data-line-number="12">    <span class="dt">UnexpectedToken</span> c z pos <span class="ot">-&gt;</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-13" data-line-number="13">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-14" data-line-number="14">        [ <span class="st">&quot;expected EOF but read&quot;</span>, pretty c, <span class="st">&quot;at&quot;</span>, pretty pos ]</a>
<a class="sourceLine" id="cb48-15" data-line-number="15">      <span class="dt">Just</span> d <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-16" data-line-number="16">        [ <span class="st">&quot;expected&quot;</span>, pretty d, <span class="st">&quot;but read&quot;</span>, pretty c, <span class="st">&quot;at&quot;</span>, pretty pos ]</a>
<a class="sourceLine" id="cb48-17" data-line-number="17"></a>
<a class="sourceLine" id="cb48-18" data-line-number="18">    <span class="dt">UnexpectedSatisfy</span> c name pos <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-19" data-line-number="19">      [ <span class="st">&quot;expected&quot;</span>, name, <span class="st">&quot;but read&quot;</span>, pretty c, <span class="st">&quot;at&quot;</span>, pretty pos ]</a>
<a class="sourceLine" id="cb48-20" data-line-number="20"></a>
<a class="sourceLine" id="cb48-21" data-line-number="21">    <span class="dt">UnexpectedDecline</span> pos <span class="ot">-&gt;</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-22" data-line-number="22">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-23" data-line-number="23">        <span class="st">&quot;expected to consume characters but encountered EOF&quot;</span></a>
<a class="sourceLine" id="cb48-24" data-line-number="24">      <span class="dt">Just</span> u <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-25" data-line-number="25">        [ <span class="st">&quot;expected to consume characters at&quot;</span>, pretty u ]</a>
<a class="sourceLine" id="cb48-26" data-line-number="26"></a>
<a class="sourceLine" id="cb48-27" data-line-number="27">    <span class="dt">UnexpectedIndentation</span> msg (u1,u2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-28" data-line-number="28">      unwords [ <span class="st">&quot;expected&quot;</span>, msg ]</a>
<a class="sourceLine" id="cb48-29" data-line-number="29"></a>
<a class="sourceLine" id="cb48-30" data-line-number="30">    <span class="dt">ExpectedBOF</span> pos <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-31" data-line-number="31">      [ <span class="st">&quot;expected beginning of stream, but found position&quot;</span>, pretty pos ]</a>
<a class="sourceLine" id="cb48-32" data-line-number="32"></a>
<a class="sourceLine" id="cb48-33" data-line-number="33">    <span class="dt">IncompleteParse</span> pos <span class="ot">-&gt;</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-34" data-line-number="34">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;expected to consume the entire stream&quot;</span></a>
<a class="sourceLine" id="cb48-35" data-line-number="35">      <span class="dt">Just</span> u <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb48-36" data-line-number="36">        [ <span class="st">&quot;expected to consume the entire stream&quot;</span></a>
<a class="sourceLine" id="cb48-37" data-line-number="37">        , <span class="st">&quot;but characters remain at position&quot;</span>, pretty u</a>
<a class="sourceLine" id="cb48-38" data-line-number="38">        ]</a>
<a class="sourceLine" id="cb48-39" data-line-number="39"></a>
<a class="sourceLine" id="cb48-40" data-line-number="40">    <span class="dt">Failure</span> msg pos <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-41" data-line-number="41">      <span class="kw">let</span> loc <span class="fu">=</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-42" data-line-number="42">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;end of stream:&quot;</span></a>
<a class="sourceLine" id="cb48-43" data-line-number="43">            <span class="dt">Just</span> u <span class="ot">-&gt;</span> <span class="st">&quot;at &quot;</span> <span class="fu">++</span> pretty u <span class="fu">++</span> <span class="st">&quot;:&quot;</span></a>
<a class="sourceLine" id="cb48-44" data-line-number="44">      <span class="kw">in</span> unwords [ loc, msg ]</a></code></pre></div>
<p><code>Annotation</code>s are similar.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Token</span> t) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Annotation</span> t) <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" data-line-number="2">  pretty a <span class="fu">=</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb49-3" data-line-number="3">    <span class="dt">Note</span> msg pos <span class="ot">-&gt;</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb49-4" data-line-number="4">      <span class="dt">Just</span> z <span class="ot">-&gt;</span> unwords [ msg, <span class="st">&quot;at&quot;</span>, pretty z ]</a>
<a class="sourceLine" id="cb49-5" data-line-number="5">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> msg</a>
<a class="sourceLine" id="cb49-6" data-line-number="6">    <span class="dt">Lookahead</span> pos <span class="ot">-&gt;</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb49-7" data-line-number="7">      <span class="dt">Just</span> z <span class="ot">-&gt;</span> unwords [ <span class="st">&quot;successful lookahead at&quot;</span>, pretty z ]</a>
<a class="sourceLine" id="cb49-8" data-line-number="8">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;successful lookahead at end of stream&quot;</span></a>
<a class="sourceLine" id="cb49-9" data-line-number="9">    <span class="dt">DeclineReason</span> pos <span class="ot">-&gt;</span> <span class="kw">case</span> pos <span class="kw">of</span></a>
<a class="sourceLine" id="cb49-10" data-line-number="10">      <span class="dt">Just</span> z <span class="ot">-&gt;</span> unwords [ <span class="st">&quot;consumption at&quot;</span>, pretty z ]</a>
<a class="sourceLine" id="cb49-11" data-line-number="11">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="st">&quot;consume at EOF&quot;</span></a></code></pre></div>
<p>Now <code>ParseError</code>s are trees, and we can make the structure of a parse error more clear by formatting it as one. We’ll use the helper type <code>Tree</code> to represent arbitrary rose trees, and <code>renderTree</code> to print them.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Tree</span> a</a>
<a class="sourceLine" id="cb50-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">T</span> a [<span class="dt">Tree</span> a]</a>
<a class="sourceLine" id="cb50-3" data-line-number="3">  <span class="kw">deriving</span> <span class="dt">Show</span></a>
<a class="sourceLine" id="cb50-4" data-line-number="4"></a>
<a class="sourceLine" id="cb50-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Tree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-6" data-line-number="6">  fmap f (<span class="dt">T</span> x bs) <span class="fu">=</span> <span class="dt">T</span> (f x) (map (fmap f) bs)</a>
<a class="sourceLine" id="cb50-7" data-line-number="7"></a>
<a class="sourceLine" id="cb50-8" data-line-number="8"><span class="ot">renderTree ::</span> <span class="dt">Tree</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb50-9" data-line-number="9">renderTree <span class="fu">=</span> render <span class="fu">.</span> addPrefix</a>
<a class="sourceLine" id="cb50-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb50-11" data-line-number="11"><span class="ot">    addPrefix ::</span> <span class="dt">Tree</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb50-12" data-line-number="12">    addPrefix (<span class="dt">T</span> x bs) <span class="fu">=</span> <span class="dt">T</span> x <span class="fu">$</span> mapLast</a>
<a class="sourceLine" id="cb50-13" data-line-number="13">      (mapRoot (<span class="st">&quot;├─ &quot;</span> <span class="fu">++</span>) (<span class="st">&quot;│  &quot;</span> <span class="fu">++</span>))</a>
<a class="sourceLine" id="cb50-14" data-line-number="14">      (mapRoot (<span class="st">&quot;└─ &quot;</span> <span class="fu">++</span>) (<span class="st">&quot;   &quot;</span> <span class="fu">++</span>))</a>
<a class="sourceLine" id="cb50-15" data-line-number="15">      (map addPrefix bs)</a>
<a class="sourceLine" id="cb50-16" data-line-number="16"></a>
<a class="sourceLine" id="cb50-17" data-line-number="17"><span class="ot">    mapRoot ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> <span class="dt">Tree</span> b</a>
<a class="sourceLine" id="cb50-18" data-line-number="18">    mapRoot f g (<span class="dt">T</span> x bs) <span class="fu">=</span> <span class="dt">T</span> (f x) (map (fmap g) bs)</a>
<a class="sourceLine" id="cb50-19" data-line-number="19"></a>
<a class="sourceLine" id="cb50-20" data-line-number="20"><span class="ot">    mapLast ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</a>
<a class="sourceLine" id="cb50-21" data-line-number="21">    mapLast f g as <span class="fu">=</span> <span class="kw">case</span> as <span class="kw">of</span></a>
<a class="sourceLine" id="cb50-22" data-line-number="22">      []   <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb50-23" data-line-number="23">      x<span class="fu">:</span>[] <span class="ot">-&gt;</span> [g x]</a>
<a class="sourceLine" id="cb50-24" data-line-number="24">      x<span class="fu">:</span>xs <span class="ot">-&gt;</span> (f x) <span class="fu">:</span> mapLast f g xs</a>
<a class="sourceLine" id="cb50-25" data-line-number="25"></a>
<a class="sourceLine" id="cb50-26" data-line-number="26"><span class="ot">    render ::</span> <span class="dt">Tree</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb50-27" data-line-number="27">    render <span class="fu">=</span> concat <span class="fu">.</span> intersperse <span class="st">&quot;\n&quot;</span> <span class="fu">.</span> flatten</a>
<a class="sourceLine" id="cb50-28" data-line-number="28"></a>
<a class="sourceLine" id="cb50-29" data-line-number="29"><span class="ot">    flatten ::</span> <span class="dt">Tree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb50-30" data-line-number="30">    flatten (<span class="dt">T</span> x bs) <span class="fu">=</span> x <span class="fu">:</span> concatMap flatten bs</a></code></pre></div>
<p>Now we can pretty print <code>Error a e</code>s by converting them to <code>Tree String</code>s first.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Pretty</span> a, <span class="dt">Pretty</span> e) <span class="ot">=&gt;</span> <span class="dt">Pretty</span> (<span class="dt">Error</span> a e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-2" data-line-number="2">  pretty <span class="fu">=</span> renderTree <span class="fu">.</span> toTree</a>
<a class="sourceLine" id="cb51-3" data-line-number="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb51-4" data-line-number="4"><span class="ot">      toTree ::</span> (<span class="dt">Pretty</span> a, <span class="dt">Pretty</span> e) <span class="ot">=&gt;</span> <span class="dt">Error</span> a e <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb51-5" data-line-number="5">      toTree err <span class="fu">=</span> <span class="kw">case</span> err <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-6" data-line-number="6">        <span class="dt">OneOf</span> es <span class="ot">-&gt;</span> <span class="kw">case</span> es <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-7" data-line-number="7">          [] <span class="ot">-&gt;</span> <span class="dt">T</span> <span class="st">&quot;unspecified failure :(&quot;</span> []</a>
<a class="sourceLine" id="cb51-8" data-line-number="8">          _  <span class="ot">-&gt;</span> <span class="dt">T</span> <span class="st">&quot;one of the following:&quot;</span> <span class="fu">$</span> map toTree es</a>
<a class="sourceLine" id="cb51-9" data-line-number="9">        <span class="dt">Because</span> a err <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-10" data-line-number="10">          <span class="kw">let</span></a>
<a class="sourceLine" id="cb51-11" data-line-number="11">            msg <span class="fu">=</span> unwords</a>
<a class="sourceLine" id="cb51-12" data-line-number="12">              [ <span class="st">&quot;expected&quot;</span>, pretty a, <span class="st">&quot;which failed due to&quot;</span> ]</a>
<a class="sourceLine" id="cb51-13" data-line-number="13">          <span class="kw">in</span> <span class="dt">T</span> msg [toTree err]</a>
<a class="sourceLine" id="cb51-14" data-line-number="14">        <span class="dt">Simply</span> e <span class="ot">-&gt;</span> <span class="dt">T</span> (pretty e) []</a>
<a class="sourceLine" id="cb51-15" data-line-number="15"></a>
<a class="sourceLine" id="cb51-16" data-line-number="16"><span class="ot">displayParseError ::</span> (<span class="dt">Token</span> t, <span class="dt">Pretty</span> t) <span class="ot">=&gt;</span> <span class="dt">ParseError</span> t <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb51-17" data-line-number="17">displayParseError <span class="fu">=</span> pretty</a></code></pre></div>
<h2 id="an-indentation-dsl">An Indentation DSL</h2>
<p>The <code>Indentation</code> type for specifying indentation relations is a little too powerful. The vast majority of the time we’ll only need one of a small number of different indentation strategies – indent by some amount, indent an extra <span class="math inline">\(k\)</span> spaces, indent to the same level. To simplify things we’ll also provide a mini DSL for constructing indentations of two basic kinds.</p>
<p>The most basic indentation pattern goes something like this: look at the (start|end) (column|line) of a successful parse, comparing it to the corresponding part of (the reference point|some specified point) using (one of a small number of relations). We can wrap up all such indentation strategies behind two functions: <code>wrtRef</code> and <code>wrtPos</code>.</p>
<p>First we need two helper types: one to represent the “dimensions” of a <code>Pos</code>, and one to represent a handful of different relations on the integers.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" data-line-number="1"><span class="co">-- | Represents either the first or last consumed position of a</span></a>
<a class="sourceLine" id="cb52-2" data-line-number="2"><span class="co">--   successful parse.</span></a>
<a class="sourceLine" id="cb52-3" data-line-number="3"><span class="kw">data</span> <span class="dt">Endpoint</span></a>
<a class="sourceLine" id="cb52-4" data-line-number="4">  <span class="fu">=</span> <span class="dt">Start</span> <span class="fu">|</span> <span class="dt">End</span></a>
<a class="sourceLine" id="cb52-5" data-line-number="5">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb52-6" data-line-number="6"></a>
<a class="sourceLine" id="cb52-7" data-line-number="7"><span class="co">-- | The dimensions of a @Pos@.</span></a>
<a class="sourceLine" id="cb52-8" data-line-number="8"><span class="kw">data</span> <span class="dt">Dimension</span></a>
<a class="sourceLine" id="cb52-9" data-line-number="9">  <span class="fu">=</span> <span class="dt">Column</span> <span class="fu">|</span> <span class="dt">Line</span></a>
<a class="sourceLine" id="cb52-10" data-line-number="10">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb52-11" data-line-number="11"></a>
<a class="sourceLine" id="cb52-12" data-line-number="12"><span class="co">-- | Basic relations on @Integer@.</span></a>
<a class="sourceLine" id="cb52-13" data-line-number="13"><span class="kw">data</span> <span class="dt">Relation</span></a>
<a class="sourceLine" id="cb52-14" data-line-number="14">  <span class="fu">=</span> <span class="dt">Eq</span>          <span class="co">-- ^ Equal to</span></a>
<a class="sourceLine" id="cb52-15" data-line-number="15">  <span class="fu">|</span> <span class="dt">Neq</span>         <span class="co">-- ^ Not equal to</span></a>
<a class="sourceLine" id="cb52-16" data-line-number="16">  <span class="fu">|</span> <span class="dt">Lt</span>          <span class="co">-- ^ Strictly less than</span></a>
<a class="sourceLine" id="cb52-17" data-line-number="17">  <span class="fu">|</span> <span class="dt">Gt</span>          <span class="co">-- ^ Strictly greater than</span></a>
<a class="sourceLine" id="cb52-18" data-line-number="18">  <span class="fu">|</span> <span class="dt">Leq</span>         <span class="co">-- ^ Less than or equal to</span></a>
<a class="sourceLine" id="cb52-19" data-line-number="19">  <span class="fu">|</span> <span class="dt">Geq</span>         <span class="co">-- ^ Greater than or equal to</span></a>
<a class="sourceLine" id="cb52-20" data-line-number="20">  <span class="fu">|</span> <span class="dt">Add</span> <span class="dt">Integer</span> <span class="co">-- ^ Fixed offset</span></a>
<a class="sourceLine" id="cb52-21" data-line-number="21">  <span class="fu">|</span> <span class="dt">Fix</span> <span class="dt">Integer</span> <span class="co">-- ^ Fixed value</span></a>
<a class="sourceLine" id="cb52-22" data-line-number="22">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Now <code>wrtRef</code> takes an endpoint, a dimenstion, and a relation and constructs an indentation strategy against the reference position.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" data-line-number="1"><span class="co">-- | Constructs a simple indentation strategy with respect to</span></a>
<a class="sourceLine" id="cb53-2" data-line-number="2"><span class="co">--   the reference position.</span></a>
<a class="sourceLine" id="cb53-3" data-line-number="3">wrtRef</a>
<a class="sourceLine" id="cb53-4" data-line-number="4"><span class="ot">  ::</span> (<span class="dt">Token</span> t, <span class="dt">Pretty</span> t)</a>
<a class="sourceLine" id="cb53-5" data-line-number="5">  <span class="ot">=&gt;</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">Dimension</span> <span class="ot">-&gt;</span> <span class="dt">Relation</span> <span class="ot">-&gt;</span> <span class="dt">Indentation</span> t</a>
<a class="sourceLine" id="cb53-6" data-line-number="6">wrtRef pt dim rel <span class="fu">=</span> <span class="dt">Indentation</span></a>
<a class="sourceLine" id="cb53-7" data-line-number="7">  { relation <span class="fu">=</span> \ref range <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-8" data-line-number="8">      getRel rel (getDim dim ref) (getDim dim <span class="fu">$</span> getPt pt range)</a>
<a class="sourceLine" id="cb53-9" data-line-number="9">  , message <span class="fu">=</span> \ref range <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-10" data-line-number="10">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-11" data-line-number="11">        labelRef <span class="fu">=</span> <span class="kw">if</span> compareRef rel</a>
<a class="sourceLine" id="cb53-12" data-line-number="12">          <span class="kw">then</span> [ <span class="st">&quot;that of the reference position at&quot;</span>, pretty ref ]</a>
<a class="sourceLine" id="cb53-13" data-line-number="13">          <span class="kw">else</span> []</a>
<a class="sourceLine" id="cb53-14" data-line-number="14">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-15" data-line-number="15">        unwords <span class="fu">$</span></a>
<a class="sourceLine" id="cb53-16" data-line-number="16">          [ labelPt pt, labelDim dim, <span class="st">&quot;of successful parse, at&quot;</span></a>
<a class="sourceLine" id="cb53-17" data-line-number="17">          , (pretty <span class="fu">$</span> getPt pt range) <span class="fu">++</span> <span class="st">&quot;,&quot;</span>, <span class="st">&quot;to&quot;</span>, labelRel rel</a>
<a class="sourceLine" id="cb53-18" data-line-number="18">          ] <span class="fu">++</span> labelRef</a>
<a class="sourceLine" id="cb53-19" data-line-number="19">  }</a></code></pre></div>
<p><code>wrtPos</code> is almost identical, but rather than the reference position, compares against a specified <code>Pos</code> value.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" data-line-number="1"><span class="co">-- | Constructs a simple indentation strategy with respect to the</span></a>
<a class="sourceLine" id="cb54-2" data-line-number="2"><span class="co">--   given position.</span></a>
<a class="sourceLine" id="cb54-3" data-line-number="3">wrtPos</a>
<a class="sourceLine" id="cb54-4" data-line-number="4"><span class="ot">  ::</span> (<span class="dt">Token</span> t, <span class="dt">Pretty</span> t)</a>
<a class="sourceLine" id="cb54-5" data-line-number="5">  <span class="ot">=&gt;</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">Dimension</span> <span class="ot">-&gt;</span> <span class="dt">Relation</span> <span class="ot">-&gt;</span> <span class="dt">Indentation</span> t</a>
<a class="sourceLine" id="cb54-6" data-line-number="6">wrtPos pos pt dim rel <span class="fu">=</span> <span class="dt">Indentation</span></a>
<a class="sourceLine" id="cb54-7" data-line-number="7">  { relation <span class="fu">=</span> \_ range <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb54-8" data-line-number="8">      getRel rel (getDim dim pos) (getDim dim <span class="fu">$</span> getPt pt range)</a>
<a class="sourceLine" id="cb54-9" data-line-number="9">  , message <span class="fu">=</span> \_ range <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb54-10" data-line-number="10">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb54-11" data-line-number="11">        labelRef <span class="fu">=</span> <span class="kw">if</span> compareRef rel</a>
<a class="sourceLine" id="cb54-12" data-line-number="12">          <span class="kw">then</span> [ <span class="st">&quot;that of position&quot;</span>, pretty pos ]</a>
<a class="sourceLine" id="cb54-13" data-line-number="13">          <span class="kw">else</span> []</a>
<a class="sourceLine" id="cb54-14" data-line-number="14">      <span class="kw">in</span></a>
<a class="sourceLine" id="cb54-15" data-line-number="15">        unwords <span class="fu">$</span></a>
<a class="sourceLine" id="cb54-16" data-line-number="16">          [ labelPt pt, labelDim dim, <span class="st">&quot;of successful parse, at&quot;</span></a>
<a class="sourceLine" id="cb54-17" data-line-number="17">          , (pretty <span class="fu">$</span> getPt pt range) <span class="fu">++</span> <span class="st">&quot;,&quot;</span>, <span class="st">&quot;to&quot;</span>, labelRel rel</a>
<a class="sourceLine" id="cb54-18" data-line-number="18">          ] <span class="fu">++</span> labelRef</a>
<a class="sourceLine" id="cb54-19" data-line-number="19">  }</a></code></pre></div>
<p>These helper functions are only needed by <code>wrtRef</code> and <code>wrtPos</code>, and aren’t part of the library proper.</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" data-line-number="1"><span class="ot">getPt ::</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> (<span class="dt">Pos</span> t, <span class="dt">Pos</span> t) <span class="ot">-&gt;</span> <span class="dt">Pos</span> t</a>
<a class="sourceLine" id="cb55-2" data-line-number="2">getPt pt <span class="fu">=</span> <span class="kw">case</span> pt <span class="kw">of</span> <span class="dt">Start</span> <span class="ot">-&gt;</span> fst; <span class="dt">End</span> <span class="ot">-&gt;</span> snd</a>
<a class="sourceLine" id="cb55-3" data-line-number="3"></a>
<a class="sourceLine" id="cb55-4" data-line-number="4"><span class="ot">getDim ::</span> <span class="dt">Dimension</span> <span class="ot">-&gt;</span> <span class="dt">Pos</span> t <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb55-5" data-line-number="5">getDim dim <span class="fu">=</span> <span class="kw">case</span> dim <span class="kw">of</span> <span class="dt">Column</span> <span class="ot">-&gt;</span> column; <span class="dt">Line</span> <span class="ot">-&gt;</span> line</a>
<a class="sourceLine" id="cb55-6" data-line-number="6"></a>
<a class="sourceLine" id="cb55-7" data-line-number="7"><span class="ot">getRel ::</span> <span class="dt">Relation</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb55-8" data-line-number="8">getRel rel <span class="fu">=</span> <span class="kw">case</span> rel <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-9" data-line-number="9">  <span class="dt">Eq</span>    <span class="ot">-&gt;</span> (<span class="fu">==</span>)</a>
<a class="sourceLine" id="cb55-10" data-line-number="10">  <span class="dt">Neq</span>   <span class="ot">-&gt;</span> (<span class="fu">/=</span>)</a>
<a class="sourceLine" id="cb55-11" data-line-number="11">  <span class="dt">Lt</span>    <span class="ot">-&gt;</span> (<span class="fu">&lt;</span>)</a>
<a class="sourceLine" id="cb55-12" data-line-number="12">  <span class="dt">Leq</span>   <span class="ot">-&gt;</span> (<span class="fu">&lt;=</span>)</a>
<a class="sourceLine" id="cb55-13" data-line-number="13">  <span class="dt">Gt</span>    <span class="ot">-&gt;</span> (<span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb55-14" data-line-number="14">  <span class="dt">Geq</span>   <span class="ot">-&gt;</span> (<span class="fu">&gt;=</span>)</a>
<a class="sourceLine" id="cb55-15" data-line-number="15">  <span class="dt">Add</span> k <span class="ot">-&gt;</span> \u v <span class="ot">-&gt;</span> v <span class="fu">==</span> u<span class="fu">+</span>k</a>
<a class="sourceLine" id="cb55-16" data-line-number="16">  <span class="dt">Fix</span> k <span class="ot">-&gt;</span> \_ v <span class="ot">-&gt;</span> v <span class="fu">==</span> k</a>
<a class="sourceLine" id="cb55-17" data-line-number="17"></a>
<a class="sourceLine" id="cb55-18" data-line-number="18"><span class="ot">labelPt ::</span> <span class="dt">Endpoint</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb55-19" data-line-number="19">labelPt pt <span class="fu">=</span> <span class="kw">case</span> pt <span class="kw">of</span> <span class="dt">Start</span> <span class="ot">-&gt;</span> <span class="st">&quot;start&quot;</span>; <span class="dt">End</span> <span class="ot">-&gt;</span> <span class="st">&quot;end&quot;</span></a>
<a class="sourceLine" id="cb55-20" data-line-number="20"></a>
<a class="sourceLine" id="cb55-21" data-line-number="21"><span class="ot">labelDim ::</span> <span class="dt">Dimension</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb55-22" data-line-number="22">labelDim dim <span class="fu">=</span> <span class="kw">case</span> dim <span class="kw">of</span> <span class="dt">Column</span> <span class="ot">-&gt;</span> <span class="st">&quot;column&quot;</span>; <span class="dt">Line</span> <span class="ot">-&gt;</span> <span class="st">&quot;Line&quot;</span></a>
<a class="sourceLine" id="cb55-23" data-line-number="23"></a>
<a class="sourceLine" id="cb55-24" data-line-number="24"><span class="ot">labelRel ::</span> <span class="dt">Relation</span> <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb55-25" data-line-number="25">labelRel rel <span class="fu">=</span> <span class="kw">case</span> rel <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-26" data-line-number="26">  <span class="dt">Eq</span>    <span class="ot">-&gt;</span> <span class="st">&quot;equal&quot;</span></a>
<a class="sourceLine" id="cb55-27" data-line-number="27">  <span class="dt">Neq</span>   <span class="ot">-&gt;</span> <span class="st">&quot;not equal&quot;</span></a>
<a class="sourceLine" id="cb55-28" data-line-number="28">  <span class="dt">Lt</span>    <span class="ot">-&gt;</span> <span class="st">&quot;be less than&quot;</span></a>
<a class="sourceLine" id="cb55-29" data-line-number="29">  <span class="dt">Leq</span>   <span class="ot">-&gt;</span> <span class="st">&quot;be less than or equal to&quot;</span></a>
<a class="sourceLine" id="cb55-30" data-line-number="30">  <span class="dt">Gt</span>    <span class="ot">-&gt;</span> <span class="st">&quot;be greater than&quot;</span></a>
<a class="sourceLine" id="cb55-31" data-line-number="31">  <span class="dt">Geq</span>   <span class="ot">-&gt;</span> <span class="st">&quot;be greater than or equal to&quot;</span></a>
<a class="sourceLine" id="cb55-32" data-line-number="32">  <span class="dt">Add</span> k <span class="ot">-&gt;</span> <span class="kw">case</span> compare k <span class="dv">0</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-33" data-line-number="33">    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="st">&quot;be exactly &quot;</span> <span class="fu">++</span> show k <span class="fu">++</span> <span class="st">&quot; more than&quot;</span></a>
<a class="sourceLine" id="cb55-34" data-line-number="34">    <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="st">&quot;equal&quot;</span></a>
<a class="sourceLine" id="cb55-35" data-line-number="35">    <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="st">&quot;be exactly &quot;</span> <span class="fu">++</span> show (<span class="fu">-</span>k) <span class="fu">++</span> <span class="st">&quot; less than&quot;</span></a>
<a class="sourceLine" id="cb55-36" data-line-number="36">  <span class="dt">Fix</span> k <span class="ot">-&gt;</span> <span class="st">&quot;be exactly &quot;</span> <span class="fu">++</span> show k</a>
<a class="sourceLine" id="cb55-37" data-line-number="37"></a>
<a class="sourceLine" id="cb55-38" data-line-number="38"><span class="ot">compareRef ::</span> <span class="dt">Relation</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb55-39" data-line-number="39">compareRef rel <span class="fu">=</span> <span class="kw">case</span> rel <span class="kw">of</span> <span class="dt">Fix</span> _ <span class="ot">-&gt;</span> <span class="dt">False</span>; _ <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>Now we can build indentation strategies by saying things like this:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" data-line-number="1"><span class="co">-- must start on the same column as the reference position</span></a>
<a class="sourceLine" id="cb56-2" data-line-number="2">wrtRef <span class="dt">Start</span> <span class="dt">Column</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb56-3" data-line-number="3"><span class="ot">  ::</span> <span class="dt">Indentation</span></a>
<a class="sourceLine" id="cb56-4" data-line-number="4"></a>
<a class="sourceLine" id="cb56-5" data-line-number="5"><span class="co">-- must start on a later line than position u</span></a>
<a class="sourceLine" id="cb56-6" data-line-number="6">indent (wrtPos u <span class="dt">Start</span> <span class="dt">Line</span> <span class="dt">Gt</span>)</a>
<a class="sourceLine" id="cb56-7" data-line-number="7"><span class="ot">  ::</span> (<span class="dt">Stream</span> s) <span class="ot">=&gt;</span> <span class="dt">Parser</span> s a <span class="ot">-&gt;</span> <span class="dt">Parser</span> s a</a></code></pre></div>
<p>These read <em>almost</em> like normal language – “with respect to the reference, the start column is equal”. Fun!</p>
<h2 id="usage-overview">Usage Overview</h2>
<p>Here’s the library documentation for inclusion on hackage.</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" data-line-number="1"><span class="co">-- $overview</span></a>
<a class="sourceLine" id="cb57-2" data-line-number="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb57-3" data-line-number="3"><span class="co">-- This library implements monadic parser combinators in the style of</span></a>
<a class="sourceLine" id="cb57-4" data-line-number="4"><span class="co">-- Parsec, but with a couple of tweaks. The major differences are</span></a>
<a class="sourceLine" id="cb57-5" data-line-number="5"><span class="co">-- as follows.</span></a>
<a class="sourceLine" id="cb57-6" data-line-number="6"><span class="co">--</span></a>
<a class="sourceLine" id="cb57-7" data-line-number="7"><span class="co">--   * The @\&lt;|&gt;@ operator from the @Alternative@ class gives the</span></a>
<a class="sourceLine" id="cb57-8" data-line-number="8"><span class="co">--     PEG-style /ordered choice/; @p \&lt;|&gt; q@ attempts @p@, and</span></a>
<a class="sourceLine" id="cb57-9" data-line-number="9"><span class="co">--     if this fails, pretends that @p@ did not consume input and</span></a>
<a class="sourceLine" id="cb57-10" data-line-number="10"><span class="co">--     attempts @q@.</span></a>
<a class="sourceLine" id="cb57-11" data-line-number="11"><span class="co">--</span></a>
<a class="sourceLine" id="cb57-12" data-line-number="12"><span class="co">--   * There is a family of /indentation sensitive/ combinators.</span></a></code></pre></div>
</body>
</html>
